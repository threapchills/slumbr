<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>SLUMBR</title>

  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#101020">
  <link rel="icon" type="image/png" href="astral_knob.png"/>

  <style>
    *{ margin:0; padding:0; box-sizing:border-box; }
    body{ font-family:Arial, sans-serif; background:#1a1a2e; overflow:hidden; user-select:none; color:white; }

    .app-container{
      width:540px; height:835px; position:relative; margin:20px auto;
    }

    .layer-switcher{
      position:absolute; top:18px; left:50%; transform:translateX(-50%);
      display:flex; gap:10px; z-index:25;
    }
    .layer-dot{
      width:14px; height:14px; border-radius:50%; border:1px solid rgba(255,255,255,0.5);
      background:rgba(0,0,0,0.7); cursor:pointer; transition:transform 0.1s ease, box-shadow 0.2s ease;
      position:relative;
    }
    .layer-dot::after{
      content:""; position:absolute; inset:3px; border-radius:50%; background:rgba(255,255,255,0.2);
      transition:opacity 0.2s ease, background 0.25s ease;
      opacity:0;
    }
    .layer-dot.active{ box-shadow:0 0 6px rgba(120,180,255,0.7); transform:scale(1.08); }
    .layer-dot.active::after{ opacity:1; background:rgba(255,255,255,0.7); }
    .layer-dot:hover{ transform:scale(1.08); }

    .layer-stack{ position:absolute; inset:0; border-radius:12px; overflow:hidden; }
    .slumbr-layer{ position:absolute; inset:0; display:none; }
    .slumbr-layer.is-active{ display:block; }

    .layer-surface{
      position:relative; width:100%; height:100%;
      background-image:url('background.png'); background-size:cover; background-position:center; background-repeat:no-repeat;
    }

    .layer-surface::after{
      content:""; position:absolute; inset:0; pointer-events:none; border:1px solid rgba(255,255,255,0.08); border-radius:12px;
    }

    .layer-badge{
      position:absolute; top:20px; left:26px; background:rgba(0,0,0,0.55); padding:6px 12px; border-radius:999px;
      font-size:12px; letter-spacing:0.08em; text-transform:uppercase; opacity:0.8; pointer-events:none;
    }

    .tintOverlay{
      position:absolute; inset:0; pointer-events:none;
      background:rgba(0,0,0,0);
      transition:background-color 0.6s ease;
      mix-blend-mode: overlay;
      border-radius:12px;
    }

    .channel{ position:absolute; display:flex; flex-direction:column; align-items:center; width:95px; height:240px; padding:4px; }
    .knob-container{ position:relative; width:75px; height:75px; }
    .knob-slider{ position:absolute; width:100%; height:100%; opacity:0; cursor:pointer; z-index:2; margin:0; }
    .knob-image{
      position:absolute; width:100%; height:100%; background-size:contain; background-repeat:no-repeat; background-position:center;
      pointer-events:none; filter:hue-rotate(180deg) saturate(1.5); transition:filter 0.1s ease;
    }
    .knob-readout{ width:75px; height:24px; text-align:center; font-size:12px; color:white; line-height:24px; margin-top:2px; }

    .channel-spinner{
      width:90px; height:36px; background:transparent; border:1.5px solid rgba(58,137,255,0.4); border-radius:8px;
      color:white; font-size:18px; text-align:center; text-align-last:center; cursor:pointer; padding:0 4px;
      -webkit-appearance:none; -moz-appearance:none; appearance:none;
    }
    .channel-spinner:focus{ outline:none; border-color:rgba(58,137,255,0.8); }
    select.channel-spinner option{ background:#1f1f3d; color:white; font-size:16px; }
    select.channel-spinner option:hover{ background:#3c3c5d; }

    .control-knob{ position:absolute; display:flex; flex-direction:column; align-items:center; }
    .control-knob.small .knob-container{ width:50px; height:50px; }
    .control-knob.small .knob-readout{ width:50px; font-size:10px; height:18px; line-height:18px; margin-top:2px; }
    .control-knob.large .knob-container{ width:150px; height:150px; }
    .control-knob.large .knob-readout{ width:150px; font-size:14px; height:24px; line-height:24px; margin-top:2px; }

    .save-load-buttons{ position:absolute; bottom:8px; left:50%; transform:translateX(-50%); display:flex; gap:20px; }
    .save-load-button{ width:120px; height:80px; background:transparent; border:none; color:white; font-size:18px; cursor:pointer; padding:10px; }
    .save-load-button:hover{ background:rgba(255,255,255,0.1); border-radius:8px; }

    .eq-buttons{ position:absolute; bottom:100px; left:50%; transform:translateX(-50%); display:flex; gap:6px; align-items:center; justify-content:center; }
    .eq-button{
      width:16px; height:16px; border-radius:50%;
      border:1px solid rgba(255,255,255,0.5); background:transparent; cursor:pointer;
      box-shadow:0 0 0 0 rgba(0,0,0,0) inset;
      transition: box-shadow 0.2s ease, transform 0.05s ease;
    }
    .eq-button:active{ transform: scale(0.96); }
    .eq-button.active{ box-shadow:0 0 0 2px rgba(255,255,255,0.45) inset; }

    .eq-white{ background: rgba(255,255,255,0.28); }
    .eq-pink { background: rgba(255,105,180,0.32); }
    .eq-green{ background: rgba(46,204,113,0.32); }
    .eq-brown{ background: rgba(165,94,41,0.32); }
    .eq-black{ background: rgba(20,24,30,0.55); }

    .channel.sky{ left:calc(28% - 47.5px); top:calc(58% - 120px); }
    .channel.fire{ left:calc(74% - 47.5px); top:calc(58% - 120px); }
    .channel.earth{ left:calc(27% - 47.5px); top:calc(78% - 120px); }
    .channel.sea{ left:calc(73% - 47.5px); top:calc(78% - 120px); }
    .control-knob.astral{ left:calc(38% - 25px); top:calc(28% - 25px); }
    .control-knob.lucid{ left:calc(62% - 25px); top:calc(28% - 25px); }
    .control-knob.master{ left:calc(50% - 75px); top:calc(64% - 75px); }

    .channel-content{ display:flex; flex-direction:column; align-items:center; justify-content:center; gap:4px; width:100%; }
    .channel.earth .channel-content > .channel-spinner,
    .channel.sea  .channel-content > .channel-spinner{ order:1; }
    .channel.earth .channel-content > .knob-container,
    .channel.sea  .channel-content > .knob-container{ order:2; }
    .channel.earth .channel-content > .knob-readout,
    .channel.sea  .channel-content > .knob-readout{ order:3; }
    .channel.sky .channel-content > .knob-container,
    .channel.fire .channel-content > .knob-container{ order:1; }
    .channel.sky .channel-content > .knob-readout,
    .channel.fire .channel-content > .knob-readout{ order:2; }
    .channel.sky .channel-content > .channel-spinner,
    .channel.fire .channel-content > .channel-spinner{ order:3; }

    .loading-indicator{
      position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      color:white; font-size:18px; text-align:center; padding:20px; background-color:rgba(0,0,0,0.5); border-radius:8px;
    }
    .progress{ margin-top:12px; width:260px; height:6px; background:rgba(255,255,255,0.15); border-radius:3px; overflow:hidden; }
    .progress-bar{ height:100%; width:0%; background:#2ecc71; transition:width 0.2s ease; }

    .layer-theme-blue .layer-surface{ filter:hue-rotate(-12deg) saturate(1.08); }
    .layer-theme-green .layer-surface{ filter:hue-rotate(28deg) saturate(1.05); }
    .layer-theme-red .layer-surface{ filter:hue-rotate(-58deg) saturate(1.12); }

    @media (max-width:560px){
      .app-container{ width:100%; height:auto; padding-bottom:154.63%; margin:5px auto; border:none; }
      .layer-stack{ position:absolute; inset:0; }
    }
  </style>
</head>
<body>
  <div class="app-container">
    <div class="layer-switcher" role="tablist" aria-label="Sound layer selector">
      <button class="layer-dot active" data-index="0" aria-label="Aurora layer"></button>
      <button class="layer-dot" data-index="1" aria-label="Verdant layer"></button>
      <button class="layer-dot" data-index="2" aria-label="Crimson layer"></button>
    </div>
    <div id="layerStack" class="layer-stack"></div>
  </div>

  <template id="slumbrLayerTemplate">
    <div class="slumbr-layer">
      <div class="layer-surface">
        <div class="layer-badge" data-id="layerBadge">Layer</div>
        <div class="tintOverlay" data-id="tintOverlay" aria-hidden="true"></div>

        <div class="loading-indicator" data-id="loadingIndicator" aria-live="polite">
          <div data-id="loadingText">Start SLUMBR</div>
          <div class="progress" aria-hidden="true">
            <div class="progress-bar" data-id="progressBar" style="width:0%"></div>
          </div>
        </div>

        <div class="control-knob astral small">
          <div class="knob-container small">
            <input type="range" min="0" max="100" value="82" class="knob-slider small" data-id="astralSlider" aria-label="Astral wet amount">
            <div class="knob-image small" data-id="astralKnob" style="background-image:url('astral_knob.png');" role="img" aria-label="Astral control"></div>
          </div>
          <div class="knob-readout" data-id="astralReadout" aria-live="polite">82</div>
        </div>

        <div class="control-knob lucid small">
          <div class="knob-container small">
            <input type="range" min="0" max="100" value="92" class="knob-slider small" data-id="lucidSlider" aria-label="Lucid modulation depth">
            <div class="knob-image small" data-id="lucidKnob" style="background-image:url('lucid_knob.png');" role="img" aria-label="Lucid control"></div>
          </div>
          <div class="knob-readout" data-id="lucidReadout" aria-live="polite">92</div>
        </div>

        <div class="channel sky">
          <div class="channel-content">
            <div class="knob-container">
              <input type="range" min="0" max="100" value="53" class="knob-slider" data-id="skySlider" aria-label="Sky channel volume">
              <div class="knob-image" data-id="skyKnob" style="background-image:url('sky_knob.png');" role="img" aria-label="Sky channel knob"></div>
            </div>
            <div class="knob-readout" data-id="skyReadout" aria-live="polite">53</div>
            <select class="channel-spinner" data-id="skySpinner" aria-label="Sky sound">
              <option value="0">Tempest</option><option value="1">Breeze</option><option value="2">Balmy</option>
              <option value="3">Temple</option><option value="4">Rain</option><option value="5">Mountains</option><option value="6">Spring</option>
            </select>
          </div>
        </div>

        <div class="channel fire">
          <div class="channel-content">
            <div class="knob-container">
              <input type="range" min="0" max="100" value="59" class="knob-slider" data-id="fireSlider" aria-label="Fire channel volume">
              <div class="knob-image" data-id="fireKnob" style="background-image:url('fire_knob.png');" role="img" aria-label="Fire channel knob"></div>
            </div>
            <div class="knob-readout" data-id="fireReadout" aria-live="polite">59</div>
            <select class="channel-spinner" data-id="fireSpinner" aria-label="Fire sound">
              <option value="0">Hearth</option><option value="1">Forge</option><option value="2">Ember</option>
              <option value="3">Crackle</option><option value="4">Campfire</option><option value="5">Summer</option><option value="6">Desert</option>
            </select>
          </div>
        </div>

        <div class="control-knob master large">
          <div class="knob-container large">
            <input type="range" min="0" max="100" value="77" class="knob-slider large" data-id="masterSlider" aria-label="Master volume">
            <div class="knob-image large" data-id="masterKnob" style="background-image:url('master_knob.png');" role="img" aria-label="Master knob"></div>
          </div>
          <div class="knob-readout" data-id="masterReadout" aria-live="polite">77</div>
        </div>

        <div class="channel earth">
          <div class="channel-content">
            <select class="channel-spinner" data-id="earthSpinner" aria-label="Earth sound">
              <option value="0">Kiln</option><option value="1">Magma</option><option value="2">Crevasse</option>
              <option value="3">Core</option><option value="4">Forest</option><option value="5">Autumn</option><option value="6">Cave</option>
            </select>
            <div class="knob-container">
              <input type="range" min="0" max="100" value="50" class="knob-slider" data-id="earthSlider" aria-label="Earth channel volume">
              <div class="knob-image" data-id="earthKnob" style="background-image:url('earth_knob.png');" role="img" aria-label="Earth channel knob"></div>
            </div>
            <div class="knob-readout" data-id="earthReadout" aria-live="polite">50</div>
          </div>
        </div>

        <div class="channel sea">
          <div class="channel-content">
            <select class="channel-spinner" data-id="seaSpinner" aria-label="Sea sound">
              <option value="0">Stormy</option><option value="1">Brook</option><option value="2">Winter</option>
              <option value="3">Lake</option><option value="4">Deep</option><option value="5">Glade</option><option value="6">Creek</option>
            </select>
            <div class="knob-container">
              <input type="range" min="0" max="100" value="55" class="knob-slider" data-id="seaSlider" aria-label="Sea channel volume">
              <div class="knob-image" data-id="seaKnob" style="background-image:url('sea_knob.png');" role="img" aria-label="Sea channel knob"></div>
            </div>
            <div class="knob-readout" data-id="seaReadout" aria-live="polite">55</div>
          </div>
        </div>

        <div class="eq-buttons" aria-label="EQ presets">
          <button class="eq-button eq-white active" data-id="eqWhite" title="White EQ" aria-label="White EQ"></button>
          <button class="eq-button eq-pink"  data-id="eqPink"  title="Pink EQ"  aria-label="Pink EQ"></button>
          <button class="eq-button eq-green" data-id="eqGreen" title="Green EQ" aria-label="Green EQ"></button>
          <button class="eq-button eq-brown" data-id="eqBrown" title="Brown EQ" aria-label="Brown EQ"></button>
          <button class="eq-button eq-black" data-id="eqBlack" title="Black EQ" aria-label="Black EQ"></button>
        </div>

        <div class="save-load-buttons">
          <button class="save-load-button" data-id="saveButton" aria-label="Save preset"></button>
          <button class="save-load-button" data-id="loadButton" aria-label="Load preset"></button>
        </div>
      </div>
    </div>
  </template>

  <script>

  class SlumbrLayer {
    constructor(root, index, options={}){
      this.root = root;
      this.index = index;
      this.options = options;
      this.audioContext = null;
      this.isInitialized = false;

      this.channels = {};
      this.masterGain = null;
      this.eq = null;
      this.limiter = null;

      this.lucidLFOComponents = {};
      this.astralLFOs = {};
      this.astralFilters = {};

      this.wakeLock = null;

      this.eqMode = 'white';
      this.eqTintMap = {
        white:{ r:255, g:255, b:255, weight:0.18 },
        pink: { r:255, g:120, b:200, weight:0.42 },
        green:{ r:46,  g:204, b:113, weight:0.42 },
        brown:{ r:165, g:94,  b:41,  weight:0.42 },
        black:{ r:24,  g:28,  b:36,  weight:0.55 }
      };

      this.INITIAL_SETTINGS = {
        master: 0.77, sky: 0.53, fire: 0.59, earth: 0.50, sea: 0.55, astral: 0.82, lucid: 0.92
      };

      /* A/B pairing maps: per channel, index -> paired index. Fallback to next if missing. */
      this.channelData = {
        sky: {
          files:['sky1.ogg','sky2.ogg','sky3.ogg','sky4.ogg','sky5.ogg','sky6.ogg','sky7.ogg'],
          labels:['Tempest','Breeze','Balmy','Temple','Rain','Mountains','Spring'],
          initialVolume:this.INITIAL_SETTINGS.sky, pan:+0.40,
          abMap:{ 0:3, 1:4, 2:5, 3:0, 4:1, 5:6, 6:2 }  // UPDATED
        },
        fire:{
          files:['fire1.ogg','fire2.ogg','fire3.ogg','fire4.ogg','fire5.ogg','fire6.ogg','fire7.ogg'],
          labels:['Hearth','Forge','Ember','Crackle','Campfire','Summer','Desert'],
          initialVolume:this.INITIAL_SETTINGS.fire, pan:-0.50,
          abMap:{ 0:6, 1:2, 2:5, 3:0, 4:1, 5:3, 6:4 }  // UPDATED
        },
        earth:{
          files:['earth1.ogg','earth2.ogg','earth3.ogg','earth4.ogg','earth5.ogg','earth6.ogg','earth7.ogg'],
          labels:['Kiln','Magma','Crevasse','Core','Forest','Autumn','Cave'],
          initialVolume:this.INITIAL_SETTINGS.earth, pan:-0.30,
          abMap:{ 0:6, 1:4, 2:5, 3:1, 4:2, 5:0, 6:3 }  // UPDATED
        },
        sea:{
          files:['sea1.ogg','sea2.ogg','sea3.ogg','sea4.ogg','sea5.ogg','sea6.ogg','sea7.ogg'],
          labels:['Stormy','Brook','Winter','Lake','Deep','Glade','Creek'],
          initialVolume:this.INITIAL_SETTINGS.sea, pan:+0.60,
          abMap:{ 0:3, 1:4, 2:6, 3:0, 4:1, 5:2, 6:5 }  // UPDATED
        }
      };
      this.orderedChannelNames = ['sky','fire','earth','sea'];

      this.layerTintBias = options.baseTint || null;
      this.layerTintBiasWeight = options.baseTintWeight ?? 0.2;

      this.initializeEventListeners();
      if(this.el('layerBadge') && options.label){ this.el('layerBadge').textContent = options.label; }
      if(this.el('loadingText') && options.startText){ this.el('loadingText').textContent = options.startText; }
      this.refreshInitialKnobColours();
    }

    el(id){ return this.root.querySelector(`[data-id="${id}"]`); }
    els(selector){ return Array.from(this.root.querySelectorAll(selector)); }

    gainFromSlider(v){ return Math.pow(v/100, 2.2); }
    randBetween(min,max){ return min + Math.random()*(max-min); }

    async initialize(){
      if(this.isInitialized) return;
      if(this.audioContext && this.audioContext.state === 'running') return;

      const loadingIndicator = this.el('loadingIndicator');
      try{
        if(!this.audioContext){
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        if(this.audioContext.state === 'suspended'){ await this.audioContext.resume(); }
        if(this.audioContext.state !== 'running'){
          loadingIndicator.textContent = 'AudioContext not running. Click again.';
          const clickListener = async ()=>{
            if(!this.isInitialized && this.audioContext && this.audioContext.state !== 'running'){ await this.initialize(); }
          };
          if(this.boundInitializeListener){ this.root.removeEventListener('click', this.boundInitializeListener); }
          this.boundInitializeListener = clickListener;
          this.root.addEventListener('click', this.boundInitializeListener, { once:true });
          return;
        }

        this.setupAudioGraph();
        this.startLFOs();

        // prime the loader at 0%
        this.updateLoadingProgress(
          0,
          this.orderedChannelNames.reduce((a,n)=>a + this.channelData[n].files.length, 0)
        );

        await this.loadAllSounds();

        this.isInitialized = true;
        loadingIndicator.style.display = 'none';
        this.loadState();

        this.requestWakeLock();
        this.updateTintOverlay();
        this.updatePanWidthFromAstral(); // set initial pan width
      }catch(err){
        console.error('Failed to initialize SLUMBR:', err);
        loadingIndicator.textContent = `Error: ${err.message}. Try refreshing.`;
        loadingIndicator.style.color = 'red';
      }
    }

    setupAudioGraph(){
      if(!this.audioContext){ return; }

      this.masterGain = this.audioContext.createGain();
      this.masterGain.gain.value = this.gainFromSlider(this.INITIAL_SETTINGS.master*100);

      /* Global EQ chain */
      const low = this.audioContext.createBiquadFilter(); low.type='lowshelf'; low.frequency.value = 200; low.gain.value = 0;
      const mid = this.audioContext.createBiquadFilter(); mid.type='peaking';  mid.frequency.value = 500; mid.Q.value = 0.7; mid.gain.value = 0;
      const high= this.audioContext.createBiquadFilter(); high.type='highshelf'; high.frequency.value = 2000; high.gain.value = 0;
      const dark= this.audioContext.createBiquadFilter(); dark.type='lowpass'; dark.frequency.value = 20000; dark.Q.value = 0.7;

      this.eq = { low, mid, high, dark };

      /* Soft limiter */
      this.limiter = this.audioContext.createDynamicsCompressor();
      this.limiter.threshold.value = -1.0;
      this.limiter.knee.value = 12;
      this.limiter.ratio.value = 12;
      this.limiter.attack.value = 0.003;
      this.limiter.release.value = 0.08;

      /* connect: master -> EQ -> limiter -> destination */
      this.masterGain.connect(low);
      low.connect(mid); mid.connect(high); high.connect(dark); dark.connect(this.limiter);
      this.limiter.connect(this.audioContext.destination);

      /* per channel setup */
      for(const channelName of this.orderedChannelNames){ this.setupChannelAudio(channelName); }

      /* default EQ mode */
      this.setEQMode('white');
    }

    setEQMode(mode){
      if(!this.eq) return;
      const { low, mid, high, dark } = this.eq;

      // reset
      low.gain.setValueAtTime(0, this.audioContext.currentTime);
      mid.gain.setValueAtTime(0, this.audioContext.currentTime);
      high.gain.setValueAtTime(0, this.audioContext.currentTime);
      dark.frequency.setValueAtTime(20000, this.audioContext.currentTime);

      if(mode === 'pink'){
        low.gain.value = +3; high.gain.value = -3; dark.frequency.value = 18000;
      } else if(mode === 'green'){
        mid.gain.value = +4; low.gain.value = -1; high.gain.value = -1; dark.frequency.value = 16000;
      } else if(mode === 'brown'){
        low.gain.value = +6; high.gain.value = -6; dark.frequency.value = 15000;
      } else if(mode === 'black'){
        low.gain.value = +4; high.gain.value = -10; dark.frequency.value = 6000;
      } // white = flat

      ['White','Pink','Green','Brown','Black'].forEach(n=>{
        const el = this.el('eq'+n);
        if(el) el.classList.toggle('active', n.toLowerCase() === mode);
      });
      this.eqMode = mode;

      this.updateTintOverlay();
    }

    setupChannelAudio(channelName){
      const channel = {};
      this.channels[channelName] = channel;

      channel.gain = this.audioContext.createGain();
      channel.gain.gain.value = this.gainFromSlider(this.channelData[channelName].initialVolume*100);

      channel.lucidEffectGainNode = this.audioContext.createGain();
      channel.gain.connect(channel.lucidEffectGainNode);

      channel.astralFilter = this.audioContext.createBiquadFilter();
      channel.astralFilter.type = 'bandpass';
      channel.astralFilter.frequency.value = 7000;
      channel.astralFilter.Q.value = 1.2;

      channel.astralWetGain = this.audioContext.createGain();
      const astralSliderElement = this.el('astralSlider');
      channel.astralWetGain.gain.value = astralSliderElement ? parseFloat(astralSliderElement.value)/100 : this.INITIAL_SETTINGS.astral;

      /* per-channel summing bus after per-source panners */
      channel.sum = this.audioContext.createGain();

      /* two stereo panners, one for A and one for B, each driven by its own slow LFO */
      channel.pannerA = this.audioContext.createStereoPanner();
      channel.pannerB = this.audioContext.createStereoPanner();
      channel.pannerA.pan.value = 0;
      channel.pannerB.pan.value = 0;

      // LFOs: 10â€“30 s cycles, unsynchronised
      channel.panLFOfreqA = this.randBetween(1/30, 1/12);
      channel.panLFOfreqB = this.randBetween(1/30, 1/12);

      channel.panLFOA = this.audioContext.createOscillator();
      channel.panLFOA.type = 'sine';
      channel.panLFOA.frequency.value = channel.panLFOfreqA;

      channel.panLFOB = this.audioContext.createOscillator();
      channel.panLFOB.type = 'sine';
      channel.panLFOB.frequency.value = channel.panLFOfreqB;

      // depth gains scaled later by Astral
      channel.panDepthA = this.audioContext.createGain();
      channel.panDepthB = this.audioContext.createGain();
      channel.panDepthA.gain.value = 0;
      channel.panDepthB.gain.value = 0;

      channel.panLFOA.connect(channel.panDepthA).connect(channel.pannerA.pan);
      channel.panLFOB.connect(channel.panDepthB).connect(channel.pannerB.pan);
      channel.panLFOA.start();
      channel.panLFOB.start();

      // route to sum
      channel.pannerA.connect(channel.sum);
      channel.pannerB.connect(channel.sum);

      // sum goes to lucid branch and astral branch as before
      channel.lucidEffectGainNode.connect(this.masterGain);
      channel.lucidEffectGainNode.connect(channel.astralFilter);
      channel.astralFilter.connect(channel.astralWetGain);
      channel.astralWetGain.connect(this.masterGain);

      // connect sum into channel fader, then into lucid envelope input
      channel.sum.connect(channel.gain);
      // channel.gain already connected to channel.lucidEffectGainNode above

      this.astralFilters[channelName] = channel.astralFilter;

      // lucid DC mixing remains unchanged
      const dcOneNode = this.audioContext.createConstantSource(); dcOneNode.offset.value = 1.0; dcOneNode.start();
      const lucidSliderElement = this.el('lucidSlider');
      const initialLucidValue = lucidSliderElement ? parseFloat(lucidSliderElement.value)/100 : this.INITIAL_SETTINGS.lucid;

      const dryMixGain = this.audioContext.createGain(); dryMixGain.gain.value = 1.0 - initialLucidValue;
      const wetMixGain = this.audioContext.createGain(); wetMixGain.gain.value = initialLucidValue;

      dcOneNode.connect(dryMixGain); dryMixGain.connect(channel.lucidEffectGainNode.gain);
      wetMixGain.connect(channel.lucidEffectGainNode.gain);
      channel.lucidControls = { dryMixGain, wetMixGain };

      // A/B pair state
      channel.pair = null;
      channel.abDepth = 0;
      channel.abPhase = Math.random()*Math.PI*2;
      channel.abFreq  = 1 / (180 + Math.random()*120);
      channel.abTimer = null;
    }

    /* NEW: loader progress updater */
    updateLoadingProgress(done, total){
      const text = this.el('loadingText');
      const bar  = this.el('progressBar');
      const pct  = total > 0 ? Math.round((done/total)*100) : 0;
      if(text) text.textContent = `Loading ${pct}%`;
      if(bar)  bar.style.width   = `${pct}%`;
    }

    /* UPDATED: loadAllSounds with progress */
    async loadAllSounds(){
      const total = this.orderedChannelNames.reduce((acc, name) => acc + this.channelData[name].files.length, 0);
      let done = 0;
      const bump = () => { done++; this.updateLoadingProgress(done, total); };

      for(const channelName of this.orderedChannelNames){
        const data = this.channelData[channelName];
        this.channels[channelName].audioBuffers = [];
        for(const filename of data.files){
          try{
            const loaded = await this.loadAudioFile(`sounds/${filename}`);
            this.channels[channelName].audioBuffers.push(loaded);
            bump();
          }catch{
            const silent = this.audioContext.createBuffer(1, Math.max(1, this.audioContext.sampleRate*0.02), this.audioContext.sampleRate);
            this.channels[channelName].audioBuffers.push({ buffer:silent, pregain:1 });
            bump();
          }
        }
      }
    }

    computeRMS(buf){
      const ch = buf.getChannelData(0);
      let sum = 0, n = 0, step = 128;
      for(let i=0;i<ch.length;i+=step){ const s = ch[i]; sum += s*s; n++; }
      return Math.sqrt(sum/Math.max(1,n));
    }

    async loadAudioFile(url){
      const response = await fetch(url);
      if(!response.ok){ throw new Error(`HTTP ${response.status} for ${url}`); }
      const arrayBuffer = await response.arrayBuffer();
      const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
      const rms = this.computeRMS(audioBuffer);
      const target = 0.16;
      const pregain = Math.min(4, Math.max(0.25, target/(rms + 1e-6)));
      return { buffer:audioBuffer, pregain };
    }

    getABIndex(channelName, index){
      const data = this.channelData[channelName];
      const map = data && data.abMap ? data.abMap : null;
      if(map && typeof map[index] !== 'undefined'){ return map[index]; }
      const len = data.files.length;
      return (index + 1) % len; // fallback: next in list
    }

    /* spinner change now sets a two-sample A/B pair per channel with mapped pairing */
    switchChannelSound(channelName, index){
      if(!this.isInitialized || !this.audioContext || this.audioContext.state !== 'running'){ return; }
      const ch = this.channels[channelName];
      const metaA = ch.audioBuffers[index];
      if(!metaA || !metaA.buffer || metaA.buffer.duration < 0.05){
        this.stopChannelPair(channelName);
        return;
      }
      const Bindex = this.getABIndex(channelName, index);
      const metaB = ch.audioBuffers[Bindex];

      const now = this.audioContext.currentTime;
      const fade = 0.35;

      const srcA = this.audioContext.createBufferSource(); srcA.buffer = metaA.buffer; srcA.loop = true;
      const preA = this.audioContext.createGain(); preA.gain.value = metaA.pregain;
      const crossA = this.audioContext.createGain(); crossA.gain.value = 1;

      const srcB = this.audioContext.createBufferSource(); srcB.buffer = metaB.buffer; srcB.loop = true;
      const preB = this.audioContext.createGain(); preB.gain.value = metaB.pregain;
      const crossB = this.audioContext.createGain(); crossB.gain.value = 0;

      // route each source through its own panner, then sum
      srcA.connect(preA).connect(crossA).connect(ch.pannerA);
      srcB.connect(preB).connect(crossB).connect(ch.pannerB);

      srcA.start(now); srcB.start(now);

      if(ch.pair){
        const { srcA:oldA, srcB:oldB, crossA:oldGA, crossB:oldGB } = ch.pair;
        try{
          oldGA.gain.cancelScheduledValues(now); oldGA.gain.setValueAtTime(oldGA.gain.value, now);
          oldGB.gain.cancelScheduledValues(now); oldGB.gain.setValueAtTime(oldGB.gain.value, now);
          oldGA.gain.linearRampToValueAtTime(0, now + fade);
          oldGB.gain.linearRampToValueAtTime(0, now + fade);
          oldA.stop(now + fade + 0.05);
          oldB.stop(now + fade + 0.05);
        }catch{}
      }

      ch.pair = { srcA, srcB, preA, preB, crossA, crossB, indexA:index, indexB:Bindex };

      // ensure pan width matches current Astral
      this.updatePanWidthFromAstral();
      this.updateABDepthForChannel(channelName);
      this.startABTimer(channelName);
    }

    stopChannelPair(channelName){
      const ch = this.channels[channelName];
      if(!ch || !ch.pair) return;
      const now = this.audioContext.currentTime;
      try{
        ch.pair.crossA.gain.linearRampToValueAtTime(0, now + 0.25);
        ch.pair.crossB.gain.linearRampToValueAtTime(0, now + 0.25);
        ch.pair.srcA.stop(now + 0.3);
        ch.pair.srcB.stop(now + 0.3);
      }catch{}
      ch.pair = null;
      if(ch.abTimer){ clearInterval(ch.abTimer); ch.abTimer = null; }
    }

    updateABDepthForChannel(channelName){
      const ch = this.channels[channelName];
      if(!ch) return;
      const L = parseFloat(this.el('lucidSlider').value)/100;
      const depth = 0.5 * Math.pow(L, 2.0);
      ch.abDepth = depth;
    }

    startABTimer(channelName){
      const ch = this.channels[channelName];
      if(!ch || !ch.pair) return;
      if(ch.abTimer){ clearInterval(ch.abTimer); ch.abTimer = null; }

      const step = 0.5;
      ch.abTimer = setInterval(()=>{
        if(!this.isInitialized || !ch.pair) return;
        const now = this.audioContext.currentTime;

        ch.abPhase += 2*Math.PI*ch.abFreq*step;

        const base = ch.abDepth * 0.5;
        const amp  = ch.abDepth * 0.15;
        let x = base + amp * Math.sin(ch.abPhase);

        x = Math.max(0, Math.min(1, x));
        const gB = Math.sin(x * Math.PI/2);
        const gA = Math.cos(x * Math.PI/2);

        ch.pair.crossA.gain.setTargetAtTime(gA, now, 0.25);
        ch.pair.crossB.gain.setTargetAtTime(gB, now, 0.25);
      }, step*1000);
    }

    /* Astral knob also controls stereo spread per source via LFO depth */
    updatePanWidthFromAstral(){
      const L = parseFloat(this.el('astralSlider').value)/100;
      // non-linear so small Astral gives near-centre, full Astral gives wide spread
      const widthMax = 0.75; // ~75% perceived width
      const depth = widthMax * Math.pow(L, 1.6);

      this.orderedChannelNames.forEach(name=>{
        const ch = this.channels[name];
        if(!ch) return;
        // set LFO depths
        ch.panDepthA.gain.setTargetAtTime(depth, this.audioContext.currentTime, 0.2);
        ch.panDepthB.gain.setTargetAtTime(depth, this.audioContext.currentTime, 0.2);
        if(depth < 0.001){
          ch.pannerA.pan.setTargetAtTime(0, this.audioContext.currentTime, 0.1);
          ch.pannerB.pan.setTargetAtTime(0, this.audioContext.currentTime, 0.1);
        }
      });
    }

    startLFOs(){
      if(!this.audioContext){ return; }

      const floorVal = 0.1;
      const lfoRange = 1.0 - floorVal;

      const createLFOEnvelope = (freq)=>{
        const osc = this.audioContext.createOscillator(); osc.frequency.value = freq; osc.type = 'sine';
        const modulationGain = this.audioContext.createGain(); modulationGain.gain.value = lfoRange/2;
        osc.connect(modulationGain);
        const baseOffset = this.audioContext.createConstantSource(); baseOffset.offset.value = (lfoRange/2) + floorVal;
        osc.start(); baseOffset.start();
        return { modulationGainNode:modulationGain, baseOffsetNode:baseOffset };
      };

      this.lucidLFOComponents.groupA = createLFOEnvelope(1/160);
      this.lucidLFOComponents.groupB = createLFOEnvelope(1/245);

      this.orderedChannelNames.forEach(name=>{
        const ch = this.channels[name];
        const group = (name === 'sky' || name === 'fire') ? this.lucidLFOComponents.groupA : this.lucidLFOComponents.groupB;
        if(ch && ch.lucidControls && ch.lucidControls.wetMixGain && group){
          group.modulationGainNode.connect(ch.lucidControls.wetMixGain);
          group.baseOffsetNode.connect(ch.lucidControls.wetMixGain);
        }
      });

      const astralFreqs = [1/160, 1/140, 1/180, 1/120];
      this.orderedChannelNames.forEach((name, i)=>{
        const lfo = this.audioContext.createOscillator();
        const lfoGain = this.audioContext.createGain();
        const baseFreqNode = this.audioContext.createConstantSource();

        lfo.frequency.value = astralFreqs[i % astralFreqs.length];
        lfo.type = 'sine';
        lfoGain.gain.value = 6000;
        baseFreqNode.offset.value = 7000;

        lfo.connect(lfoGain);
        if(this.astralFilters[name] && this.astralFilters[name].frequency){
          lfoGain.connect(this.astralFilters[name].frequency);
          baseFreqNode.connect(this.astralFilters[name].frequency);
        }
        lfo.start(); baseFreqNode.start();
        this.astralLFOs[name] = { lfo, lfoGain, baseFreqNode };
      });
    }

    updateKnobColor(elementId, percentage){
      const knobImage = this.el(elementId);
      if(!knobImage) return;
      const value = parseFloat(percentage)/100;
      const hueMinDeg = 0, hueMaxDeg = 180;
      const targetHue = hueMinDeg + (hueMaxDeg - hueMinDeg)*value;
      const brightness = 0.8 + 0.4*value;
      knobImage.style.filter = `hue-rotate(${targetHue}deg) saturate(1.5) brightness(${brightness})`;

    }

    refreshInitialKnobColours(){
      ['astral','lucid','master','sky','fire','earth','sea'].forEach(name=>{
        const slider = this.el(`${name}Slider`);
        if(slider){ this.updateKnobColor(`${name}Knob`, parseFloat(slider.value)); }
      });
      this.updateTintOverlay();
    }

    /* global tint: blend channel mix colour with EQ mode tint */
    updateTintOverlay(){
      const vSky   = parseFloat(this.el('skySlider').value)/100;
      const vFire  = parseFloat(this.el('fireSlider').value)/100;
      const vEarth = parseFloat(this.el('earthSlider').value)/100;
      const vSea   = parseFloat(this.el('seaSlider').value)/100;

      const col = (r,g,b)=>({r,g,b});
      const skyPink = col(255,105,180);
      const fireOrng= col(255,140,0);
      const earthGrn= col(46,204,113);
      const seaBlue = col(64,156,255);

      const wSum = vSky + vFire + vEarth + vSea + 1e-6;
      const chanCol = {
        r:(vSky*skyPink.r + vFire*fireOrng.r + vEarth*earthGrn.r + vSea*seaBlue.r) / wSum,
        g:(vSky*skyPink.g + vFire*fireOrng.g + vEarth*earthGrn.g + vSea*seaBlue.g) / wSum,
        b:(vSky*skyPink.b + vFire*fireOrng.b + vEarth*earthGrn.b + vSea*seaBlue.b) / wSum
      };

      const bias = this.eqTintMap[this.eqMode] || this.eqTintMap.white;
      const t = bias.weight;
      let final = {
        r: chanCol.r*(1-t) + bias.r*t,
        g: chanCol.g*(1-t) + bias.g*t,
        b: chanCol.b*(1-t) + bias.b*t
      };

      if(this.layerTintBias){
        const weight = Math.min(0.45, Math.max(0, this.layerTintBiasWeight));
        final = {
          r: final.r*(1-weight) + this.layerTintBias.r*weight,
          g: final.g*(1-weight) + this.layerTintBias.g*weight,
          b: final.b*(1-weight) + this.layerTintBias.b*weight
        };
      }

      const alpha = Math.min(0.92, 0.30 + 0.50 * ((wSum - 1e-6) / 4));
      const overlay = this.el('tintOverlay');
      overlay.style.backgroundColor = `rgba(${final.r.toFixed(0)}, ${final.g.toFixed(0)}, ${final.b.toFixed(0)}, ${alpha.toFixed(3)})`;
    }

    fadeIn(gainParam, t, d=0.08){
      gainParam.cancelScheduledValues(t);
      gainParam.setValueAtTime(0, t);
      gainParam.linearRampToValueAtTime(1, t + d);
    }
    fadeOut(gainParam, t, d=0.08){
      gainParam.cancelScheduledValues(t);
      gainParam.setValueAtTime(gainParam.value, t);
      gainParam.linearRampToValueAtTime(0, t + d);
    }

    initializeEventListeners(){
      this.boundInitializeListener = async ()=>{
        if(!this.isInitialized){ await this.initialize(); }
        else if(this.audioContext && this.audioContext.state === 'suspended'){ await this.audioContext.resume(); }
      };
      this.root.addEventListener('click', this.boundInitializeListener, { once:true });

      const masterSlider = this.el('masterSlider');
      const masterReadout = this.el('masterReadout');
      masterSlider.addEventListener('input', (e)=>{
        if(!this.isInitialized || !this.masterGain) return;
        const t = this.audioContext.currentTime;
        const g = this.gainFromSlider(parseFloat(e.target.value));
        this.masterGain.gain.setTargetAtTime(g, t, 0.015);
        masterReadout.textContent = e.target.value;
        this.updateKnobColor('masterKnob', parseFloat(e.target.value));
        this.updateTintOverlay();
      });

      const astralSlider = this.el('astralSlider');
      const astralReadout = this.el('astralReadout');
      astralSlider.addEventListener('input', (e)=>{
        if(!this.isInitialized) return;
        const value = parseFloat(e.target.value)/100;
        this.orderedChannelNames.forEach(n=>{
          const ch = this.channels[n];
          if(ch && ch.astralWetGain){
            ch.astralWetGain.gain.setTargetAtTime(value, this.audioContext.currentTime, 0.015);
          }
        });
        this.updatePanWidthFromAstral(); // tie stereo spread to Astral
        astralReadout.textContent = e.target.value;
        this.updateKnobColor('astralKnob', parseFloat(e.target.value));
      });

      const lucidSlider = this.el('lucidSlider');
      const lucidReadout = this.el('lucidReadout');
      lucidSlider.addEventListener('input', (e)=>{
        if(!this.isInitialized) return;
        const L = parseFloat(e.target.value)/100;
        this.orderedChannelNames.forEach(n=>{
          const ch = this.channels[n];
          if(ch && ch.lucidControls){
            ch.lucidControls.dryMixGain.gain.setTargetAtTime(1 - L, this.audioContext.currentTime, 0.015);
            ch.lucidControls.wetMixGain.gain.setTargetAtTime(L, this.audioContext.currentTime, 0.015);
          }
          this.updateABDepthForChannel(n);
        });
        lucidReadout.textContent = e.target.value;
        this.updateKnobColor('lucidKnob', parseFloat(e.target.value));
      });

      this.orderedChannelNames.forEach(channelName=>{
        const slider  = this.el(`${channelName}Slider`);
        const readout = this.el(`${channelName}Readout`);
        const spinner = this.el(`${channelName}Spinner`);

        slider.addEventListener('input', (e)=>{
          if(!this.isInitialized) return;
          const v = this.gainFromSlider(parseFloat(e.target.value));
          if(this.channels[channelName] && this.channels[channelName].gain){
            this.channels[channelName].gain.gain.setTargetAtTime(v, this.audioContext.currentTime, 0.015);
          }
          readout.textContent = e.target.value;
          this.updateKnobColor(`${channelName}Knob`, parseFloat(e.target.value));
          this.updateTintOverlay();
        });

        spinner.addEventListener('change', (e)=>{
          if(!this.isInitialized) return;
          const index = parseInt(e.target.value, 10);
          this.switchChannelSound(channelName, index);
        });
      });

      const eqMap = { eqWhite:'white', eqPink:'pink', eqGreen:'green', eqBrown:'brown', eqBlack:'black' };
      Object.keys(eqMap).forEach(id=>{
        const mode = eqMap[id];
        const el = this.el(id);
        el.addEventListener('click', ()=> this.setEQMode(mode));
      });

      this.el('saveButton').addEventListener('click', ()=> this.saveState());
      this.el('loadButton').addEventListener('click', ()=> this.loadState());
    }

    saveState(){
      if(!this.isInitialized){ return; }
      const state = {
        master: this.el('masterSlider').value,
        astral: this.el('astralSlider').value,
        lucid: this.el('lucidSlider').value,
        eq: this.eqMode || 'white',
        channels: {}
      };
      this.orderedChannelNames.forEach(n=>{
        state.channels[n] = {
          volume: this.el(`${n}Slider`).value,
          selection: this.el(`${n}Spinner`).value
        };
      });
      localStorage.setItem(this.storageKey(), JSON.stringify(state));
    }

    loadState(){
      if(!this.isInitialized){ return; }
      let s = null;
      const saved = this.loadStoredState();
      if(saved){ try{ s = JSON.parse(saved);}catch{} }

      if(!s){
        s = {
          master: this.el('masterSlider').value,
          astral: this.el('astralSlider').value,
          lucid: this.el('lucidSlider').value,
          eq: 'white',
          channels: {}
        };
        this.orderedChannelNames.forEach(n=>{
          s.channels[n] = {
            volume: this.el(`${n}Slider`).value,
            selection: this.el(`${n}Spinner`).value
          };
        });
      }

      this.el('masterSlider').value = s.master;
      this.el('masterSlider').dispatchEvent(new Event('input', { bubbles:true }));

      this.el('astralSlider').value = s.astral;
      this.el('astralSlider').dispatchEvent(new Event('input', { bubbles:true }));

      this.el('lucidSlider').value = s.lucid;
      this.el('lucidSlider').dispatchEvent(new Event('input', { bubbles:true }));

      if(s.channels){
        this.orderedChannelNames.forEach(n=>{
          const cs = s.channels[n];
          if(!cs) return;
          this.el(`${n}Slider`).value = cs.volume;
          this.el(`${n}Slider`).dispatchEvent(new Event('input', { bubbles:true }));

          this.el(`${n}Spinner`).value = cs.selection;
          this.el(`${n}Spinner`).dispatchEvent(new Event('change', { bubbles:true }));
        });
      }

      this.setEQMode(s.eq || 'white');
      this.updatePanWidthFromAstral();
    }

    storageKey(){
      return `slumbr_state_v7_layer_${this.index}`;
    }

    loadStoredState(){
      const primary = localStorage.getItem(this.storageKey());
      if(primary) return primary;
      if(this.index === 0){
        return localStorage.getItem('slumbr_state_v6') || localStorage.getItem('slumbr_state_v5');
      }
      return null;
    }

    async requestWakeLock(){
      if('wakeLock' in navigator){
        try{
          this.wakeLock = await navigator.wakeLock.request('screen');
          this.wakeLock.addEventListener('release', ()=>{});
          document.addEventListener('visibilitychange', async ()=>{
            if(document.visibilityState === 'visible'){
              try{ this.wakeLock = await navigator.wakeLock.request('screen'); }catch{}
            }
          });
        }catch{}
      }
    }

    setVisible(isVisible){
      const active = !!isVisible;
      this.root.classList.toggle('is-active', active);
      this.root.style.display = active ? 'block' : 'none';
      if(active){ this.updateTintOverlay(); }
    }
  }

  class SlumbrLayersManager {
    constructor(){
      this.layerStack = document.getElementById('layerStack');
      this.template = document.getElementById('slumbrLayerTemplate');
      this.layerButtons = Array.from(document.querySelectorAll('.layer-dot'));
      this.layers = [];
      this.activeIndex = 0;

      this.layerConfigs = [
        { label:'Aurora', baseTint:{ r:120, g:180, b:255 }, baseTintWeight:0.30, theme:'layer-theme-blue', startText:'Start Aurora' },
        { label:'Verdant', baseTint:{ r:110, g:240, b:170 }, baseTintWeight:0.28, theme:'layer-theme-green', startText:'Start Verdant' },
        { label:'Crimson', baseTint:{ r:255, g:150, b:160 }, baseTintWeight:0.32, theme:'layer-theme-red', startText:'Start Crimson' }
      ];

      this.layerButtons.forEach((button, idx)=>{
        button.addEventListener('click', ()=> this.activateLayer(idx));
      });

      this.ensureLayer(0);
      this.activateLayer(0);
    }

    ensureLayer(index){
      if(this.layers[index]) return this.layers[index];
      const config = this.layerConfigs[index] || {};
      const fragment = this.template.content.firstElementChild.cloneNode(true);
      if(config.theme){ fragment.classList.add(config.theme); }
      fragment.style.display = 'none';
      this.layerStack.appendChild(fragment);
      const layer = new SlumbrLayer(fragment, index, config);
      this.layers[index] = layer;
      return layer;
    }

    activateLayer(index){
      const layer = this.ensureLayer(index);
      if(!layer) return;
      this.layers.forEach((l, idx)=>{ if(l){ l.setVisible(idx === index); } });
      this.layerButtons.forEach((btn, idx)=> btn.classList.toggle('active', idx === index));
      this.activeIndex = index;
    }

    saveAll(){
      this.layers.forEach(layer=>{ if(layer && layer.isInitialized){ layer.saveState(); } });
    }
  }

  const slumbrLayers = new SlumbrLayersManager();

  window.addEventListener('beforeunload', ()=> slumbrLayers.saveAll());

  if('serviceWorker' in navigator){
    window.addEventListener('load', ()=>{ navigator.serviceWorker.register('./sw.js').catch(()=>{}); });
  }

  </script>

  <div style="text-align:center; margin-top:20px;">
    <a href="https://mikewhyle.com/ai/" target="_blank" rel="noopener">
      <img src="ad-mikewhyle-ai-consultant.png" alt="AI Consultant" style="max-width:100%; height:auto;">
    </a>
  </div>
</body>
</html>
  

  

  
  
