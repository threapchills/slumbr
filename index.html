<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>SLUMBR</title>

  <!-- PWA -->
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#101020">
  <link rel="icon" type="image/png" href="astral_knob.png"/>

  <style>
    *{ margin:0; padding:0; box-sizing:border-box; }
    body{ font-family:Arial, sans-serif; background:#1a1a2e; overflow:hidden; user-select:none; color:white; }

    .app-container{
      width:540px; height:835px; position:relative; margin:20px auto;
      background-image:url('background.png'); background-size:cover; background-position:center; background-repeat:no-repeat;
    }

    .channel{
      position:absolute; display:flex; flex-direction:column; align-items:center;
      width:95px; height:240px; padding:4px;
    }

    .knob-container{ position:relative; width:75px; height:75px; }
    .knob-slider{ position:absolute; width:100%; height:100%; opacity:0; cursor:pointer; z-index:2; margin:0; }
    .knob-image{
      position:absolute; width:100%; height:100%; background-size:contain; background-repeat:no-repeat; background-position:center;
      pointer-events:none; filter:hue-rotate(180deg) saturate(1.5); transition:filter 0.1s ease;
    }
    .knob-readout{ width:75px; height:24px; text-align:center; font-size:12px; color:white; line-height:24px; margin-top:2px; }

    .channel-spinner{
      width:90px; height:36px; background:transparent; border:1.5px solid rgba(58,137,255,0.4); border-radius:8px;
      color:white; font-size:18px; text-align:center; text-align-last:center; cursor:pointer; padding:0 4px;
      -webkit-appearance:none; -moz-appearance:none; appearance:none;
    }
    .channel-spinner:focus{ outline:none; border-color:rgba(58,137,255,0.8); }
    select.channel-spinner option{ background:#1f1f3d; color:white; font-size:16px; }
    select.channel-spinner option:hover{ background:#3c3c5d; }

    .control-knob{ position:absolute; display:flex; flex-direction:column; align-items:center; }
    .control-knob.small .knob-container{ width:50px; height:50px; }
    .control-knob.small .knob-readout{ width:50px; font-size:10px; height:18px; line-height:18px; margin-top:2px; }
    .control-knob.large .knob-container{ width:150px; height:150px; }
    .control-knob.large .knob-readout{ width:150px; font-size:14px; height:24px; line-height:24px; margin-top:2px; }

    .save-load-buttons{ position:absolute; bottom:8px; left:50%; transform:translateX(-50%); display:flex; gap:20px; }
    .save-load-button{ width:120px; height:80px; background:transparent; border:none; color:white; font-size:18px; cursor:pointer; padding:10px; }
    .save-load-button:hover{ background:rgba(255,255,255,0.1); border-radius:8px; }

    /* Layout anchors preserved exactly */
    .channel.sky{ left:calc(28% - 47.5px); top:calc(58% - 120px); }
    .channel.fire{ left:calc(74% - 47.5px); top:calc(58% - 120px); }
    .channel.earth{ left:calc(27% - 47.5px); top:calc(78% - 120px); }
    .channel.sea{ left:calc(73% - 47.5px); top:calc(78% - 120px); }
    .control-knob.astral{ left:calc(38% - 25px); top:calc(28% - 25px); }
    .control-knob.lucid{ left:calc(62% - 25px); top:calc(28% - 25px); }
    .control-knob.master{ left:calc(50% - 75px); top:calc(64% - 75px); }

    .channel-content{ display:flex; flex-direction:column; align-items:center; justify-content:center; gap:4px; width:100%; }
    .channel.earth .channel-content > .channel-spinner,
    .channel.sea .channel-content > .channel-spinner{ order:1; }
    .channel.earth .channel-content > .knob-container,
    .channel.sea .channel-content > .knob-container{ order:2; }
    .channel.earth .channel-content > .knob-readout,
    .channel.sea .channel-content > .knob-readout{ order:3; }

    .channel.sky .channel-content > .knob-container,
    .channel.fire .channel-content > .knob-container{ order:1; }
    .channel.sky .channel-content > .knob-readout,
    .channel.fire .channel-content > .knob-readout{ order:2; }
    .channel.sky .channel-content > .channel-spinner,
    .channel.fire .channel-content > .channel-spinner{ order:3; }

    .loading-indicator{
      position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      color:white; font-size:18px; text-align:center; padding:20px; background-color:rgba(0,0,0,0.5); border-radius:8px;
    }

    @media (max-width:560px){
      .app-container{ width:100%; height:auto; padding-bottom:154.63%; margin:5px auto; border:none; }
      /* do not touch other positions, per your instruction */
    }
  </style>
</head>
<body>
  <div class="app-container">
    <div class="loading-indicator" id="loadingIndicator" aria-live="polite">Start SLUMBR</div>

    <div class="control-knob astral small">
      <div class="knob-container small">
        <input type="range" min="0" max="100" value="82" class="knob-slider small" id="astralSlider" aria-label="Astral wet amount">
        <div class="knob-image small" id="astralKnob" style="background-image:url('astral_knob.png');" role="img" aria-label="Astral control"></div>
      </div>
      <div class="knob-readout" id="astralReadout" aria-live="polite">82</div>
    </div>

    <div class="control-knob lucid small">
      <div class="knob-container small">
        <input type="range" min="0" max="100" value="92" class="knob-slider small" id="lucidSlider" aria-label="Lucid modulation depth">
        <div class="knob-image small" id="lucidKnob" style="background-image:url('lucid_knob.png');" role="img" aria-label="Lucid control"></div>
      </div>
      <div class="knob-readout" id="lucidReadout" aria-live="polite">92</div>
    </div>

    <div class="channel sky">
      <div class="channel-content">
        <div class="knob-container">
          <input type="range" min="0" max="100" value="53" class="knob-slider" id="skySlider" aria-label="Sky channel volume">
          <div class="knob-image" id="skyKnob" style="background-image:url('sky_knob.png');" role="img" aria-label="Sky channel knob"></div>
        </div>
        <div class="knob-readout" id="skyReadout" aria-live="polite">53</div>
        <select class="channel-spinner" id="skySpinner" aria-label="Sky sound">
          <option value="0">Tempest</option><option value="1">Breeze</option><option value="2">Balmy</option>
          <option value="3">Temple</option><option value="4">Rain</option><option value="5">Mountains</option><option value="6">Spring</option>
        </select>
      </div>
    </div>

    <div class="channel fire">
      <div class="channel-content">
        <div class="knob-container">
          <input type="range" min="0" max="100" value="59" class="knob-slider" id="fireSlider" aria-label="Fire channel volume">
          <div class="knob-image" id="fireKnob" style="background-image:url('fire_knob.png');" role="img" aria-label="Fire channel knob"></div>
        </div>
        <div class="knob-readout" id="fireReadout" aria-live="polite">59</div>
        <select class="channel-spinner" id="fireSpinner" aria-label="Fire sound">
          <option value="0">Hearth</option><option value="1">Forge</option><option value="2">Ember</option>
          <option value="3">Crackle</option><option value="4">Campfire</option><option value="5">Summer</option><option value="6">Desert</option>
        </select>
      </div>
    </div>

    <div class="control-knob master large">
      <div class="knob-container large">
        <input type="range" min="0" max="100" value="77" class="knob-slider large" id="masterSlider" aria-label="Master volume">
        <div class="knob-image large" id="masterKnob" style="background-image:url('master_knob.png');" role="img" aria-label="Master knob"></div>
      </div>
      <div class="knob-readout" id="masterReadout" aria-live="polite">77</div>
    </div>

    <div class="channel earth">
      <div class="channel-content">
        <select class="channel-spinner" id="earthSpinner" aria-label="Earth sound">
          <option value="0">Kiln</option><option value="1">Magma</option><option value="2">Crevasse</option>
          <option value="3">Core</option><option value="4">Forest</option><option value="5">Autumn</option><option value="6">Cave</option>
        </select>
        <div class="knob-container">
          <input type="range" min="0" max="100" value="50" class="knob-slider" id="earthSlider" aria-label="Earth channel volume">
          <div class="knob-image" id="earthKnob" style="background-image:url('earth_knob.png');" role="img" aria-label="Earth channel knob"></div>
        </div>
        <div class="knob-readout" id="earthReadout" aria-live="polite">50</div>
      </div>
    </div>

    <div class="channel sea">
      <div class="channel-content">
        <select class="channel-spinner" id="seaSpinner" aria-label="Sea sound">
          <option value="0">Stormy</option><option value="1">Brook</option><option value="2">Winter</option>
          <option value="3">Lake</option><option value="4">Deep</option><option value="5">Glade</option><option value="6">Creek</option>
        </select>
        <div class="knob-container">
          <input type="range" min="0" max="100" value="55" class="knob-slider" id="seaSlider" aria-label="Sea channel volume">
          <div class="knob-image" id="seaKnob" style="background-image:url('sea_knob.png');" role="img" aria-label="Sea channel knob"></div>
        </div>
        <div class="knob-readout" id="seaReadout" aria-live="polite">55</div>
      </div>
    </div>

    <div class="save-load-buttons">
      <button class="save-load-button" id="saveButton" aria-label="Save preset"></button>
      <button class="save-load-button" id="loadButton" aria-label="Load preset"></button>
    </div>
  </div>

  <script>
  class SlumbrApp {
    constructor(){
      this.audioContext = null;
      this.isInitialized = false;
      this.channels = {};
      this.masterGain = null;
      this.limiter = null;

      this.lucidLFOComponents = {};
      this.astralLFOs = {};
      this.astralFilters = {};

      this.wakeLock = null;

      this.INITIAL_SETTINGS = {
        master: 0.77, sky: 0.53, fire: 0.59, earth: 0.50, sea: 0.55, astral: 0.82, lucid: 0.92
      };

      this.channelData = {
        sky:   { files:['sky1.ogg','sky2.ogg','sky3.ogg','sky4.ogg','sky5.ogg','sky6.ogg','sky7.ogg'], labels:['Tempest','Breeze','Balmy','Temple','Rain','Mountains','Spring'], initialVolume:this.INITIAL_SETTINGS.sky,   pan:+0.40 },
        fire:  { files:['fire1.ogg','fire2.ogg','fire3.ogg','fire4.ogg','fire5.ogg','fire6.ogg','fire7.ogg'], labels:['Hearth','Forge','Ember','Crackle','Campfire','Summer','Desert'], initialVolume:this.INITIAL_SETTINGS.fire,  pan:-0.50 },
        earth: { files:['earth1.ogg','earth2.ogg','earth3.ogg','earth4.ogg','earth5.ogg','earth6.ogg','earth7.ogg'], labels:['Kiln','Magma','Crevasse','Core','Forest','Autumn','Cave'], initialVolume:this.INITIAL_SETTINGS.earth, pan:-0.30 },
        sea:   { files:['sea1.ogg','sea2.ogg','sea3.ogg','sea4.ogg','sea5.ogg','sea6.ogg','sea7.ogg'], labels:['Stormy','Brook','Winter','Lake','Deep','Glade','Creek'], initialVolume:this.INITIAL_SETTINGS.sea,   pan:+0.60 }
      };
      this.orderedChannelNames = ['sky','fire','earth','sea'];
      this.initializeEventListeners();
    }

    /* perceptual mapping */
    gainFromSlider(v){ return Math.pow(v/100, 2.2); }

    async initialize(){
      if(this.isInitialized) return;
      if(this.audioContext && this.audioContext.state === 'running') return;

      const loadingIndicator = document.getElementById('loadingIndicator');
      try{
        if(!this.audioContext){
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        if(this.audioContext.state === 'suspended'){ await this.audioContext.resume(); }
        if(this.audioContext.state !== 'running'){
          loadingIndicator.textContent = 'AudioContext not running. Click again.';
          const clickListener = async ()=>{
            if(!this.isInitialized && this.audioContext && this.audioContext.state !== 'running'){ await this.initialize(); }
          };
          if(this.boundInitializeListener){ document.removeEventListener('click', this.boundInitializeListener); }
          this.boundInitializeListener = clickListener;
          document.addEventListener('click', this.boundInitializeListener, { once:true });
          return;
        }

        this.setupAudioGraph();
        this.startLFOs();
        await this.loadAllSounds();

        this.isInitialized = true;
        loadingIndicator.style.display = 'none';
        this.loadState();

        this.requestWakeLock(); // screen stays on
      }catch(err){
        console.error('Failed to initialize SLUMBR:', err);
        loadingIndicator.textContent = `Error: ${err.message}. Try refreshing.`;
        loadingIndicator.style.color = 'red';
      }
    }

    setupAudioGraph(){
      if(!this.audioContext){ return; }

      this.masterGain = this.audioContext.createGain();
      this.masterGain.gain.value = this.gainFromSlider(this.INITIAL_SETTINGS.master*100);

      // Soft limiter
      this.limiter = this.audioContext.createDynamicsCompressor();
      this.limiter.threshold.value = -1.0;
      this.limiter.knee.value = 12;
      this.limiter.ratio.value = 12;
      this.limiter.attack.value = 0.003;
      this.limiter.release.value = 0.08;

      this.masterGain.connect(this.limiter);
      this.limiter.connect(this.audioContext.destination);

      for(const channelName of this.orderedChannelNames){ this.setupChannelAudio(channelName); }
    }

    setupChannelAudio(channelName){
      const channel = {};
      this.channels[channelName] = channel;

      // Per-channel end of chain gain
      channel.gain = this.audioContext.createGain();
      channel.gain.gain.value = this.gainFromSlider(this.channelData[channelName].initialVolume*100);

      // Lucid envelope gain node sits after the channel gain
      channel.lucidEffectGainNode = this.audioContext.createGain();
      channel.gain.connect(channel.lucidEffectGainNode);

      // Astral path
      channel.astralFilter = this.audioContext.createBiquadFilter();
      channel.astralFilter.type = 'bandpass';
      channel.astralFilter.frequency.value = 7000;
      channel.astralFilter.Q.value = 1.2;

      channel.astralWetGain = this.audioContext.createGain();
      const astralSliderElement = document.getElementById('astralSlider');
      channel.astralWetGain.gain.value = astralSliderElement ? parseFloat(astralSliderElement.value)/100 : this.INITIAL_SETTINGS.astral;

      // Route dry to master and also to astral branch
      channel.lucidEffectGainNode.connect(this.masterGain);
      channel.lucidEffectGainNode.connect(channel.astralFilter);
      channel.astralFilter.connect(channel.astralWetGain);
      channel.astralWetGain.connect(this.masterGain);

      // For Astral LFO access
      this.astralFilters[channelName] = channel.astralFilter;

      // Lucid amplitude shaping via DC + LFO
      const dcOneNode = this.audioContext.createConstantSource(); dcOneNode.offset.value = 1.0; dcOneNode.start();
      const lucidSliderElement = document.getElementById('lucidSlider');
      const initialLucidValue = lucidSliderElement ? parseFloat(lucidSliderElement.value)/100 : this.INITIAL_SETTINGS.lucid;

      const dryMixGain = this.audioContext.createGain(); dryMixGain.gain.value = 1.0 - initialLucidValue;
      const wetMixGain = this.audioContext.createGain(); wetMixGain.gain.value = initialLucidValue;

      dcOneNode.connect(dryMixGain); dryMixGain.connect(channel.lucidEffectGainNode.gain);
      wetMixGain.connect(channel.lucidEffectGainNode.gain);

      channel.lucidControls = { dryMixGain, wetMixGain };

      // Stereo panner per channel with tiny slow drift
      channel.panner = this.audioContext.createStereoPanner();
      channel.panner.pan.value = this.channelData[channelName].pan;

      // Slow drift
      const panLFO = this.audioContext.createOscillator();
      const panGain = this.audioContext.createGain();
      panGain.gain.value = 0.05; // subtle
      panLFO.frequency.value = 0.005; // one cycle ~200 s
      panLFO.connect(panGain).connect(channel.panner.pan);
      panLFO.start();

      // Final route after panner goes into the channel gain
      channel.panner.connect(channel.gain);
    }

    async loadAllSounds(){
      for(const channelName of this.orderedChannelNames){
        const data = this.channelData[channelName];
        this.channels[channelName].audioBuffers = [];
        for(const filename of data.files){
          try{
            const loaded = await this.loadAudioFile(`sounds/${filename}`);
            this.channels[channelName].audioBuffers.push(loaded); // {buffer, pregain}
          }catch{
            const silent = this.audioContext.createBuffer(1, Math.max(1, this.audioContext.sampleRate*0.02), this.audioContext.sampleRate);
            this.channels[channelName].audioBuffers.push({ buffer:silent, pregain:1 });
          }
        }
      }
    }

    computeRMS(buf){
      const ch = buf.getChannelData(0);
      let sum = 0, n = 0;
      const step = 128;
      for(let i=0; i<ch.length; i+=step){ const s = ch[i]; sum += s*s; n++; }
      const rms = Math.sqrt(sum/Math.max(1,n));
      return rms;
    }

    async loadAudioFile(url){
      const response = await fetch(url);
      if(!response.ok){ throw new Error(`HTTP ${response.status} for ${url}`); }
      const arrayBuffer = await response.arrayBuffer();
      const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
      const rms = this.computeRMS(audioBuffer);
      const target = 0.16;
      const pregain = Math.min(4, Math.max(0.25, target/(rms + 1e-6)));
      return { buffer: audioBuffer, pregain };
    }

    /* crossfade on spinner change */
    switchChannelSound(channelName, index){
      if(!this.isInitialized || !this.audioContext || this.audioContext.state !== 'running'){ return; }
      const channel = this.channels[channelName];
      const fileMeta = channel.audioBuffers[index];
      if(!fileMeta || !fileMeta.buffer || fileMeta.buffer.duration < 0.05){
        if(channel.currentSource){ try{ channel.currentSource.stop(); channel.currentSource.disconnect(); }catch{} }
        channel.currentSource = null; return;
      }

      const now = this.audioContext.currentTime;
      const fade = 0.4;

      // New source chain: src -> preGain(pregain) -> crossGain(0..1) -> panner -> channel.gain -> lucid -> master
      const srcIn = this.audioContext.createBufferSource();
      srcIn.buffer = fileMeta.buffer;
      srcIn.loop = true;

      const preGain = this.audioContext.createGain();
      preGain.gain.value = fileMeta.pregain;

      const crossGain = this.audioContext.createGain();
      crossGain.gain.value = 0;

      srcIn.connect(preGain).connect(crossGain).connect(channel.panner);

      // Fade out old source if any
      if(channel.currentGain){
        const g = channel.currentGain.gain;
        g.cancelScheduledValues(now);
        g.setValueAtTime(g.value, now);
        g.linearRampToValueAtTime(0, now + fade);
        try{ channel.currentSource.stop(now + fade + 0.05); }catch{}
      }

      // Fade in new
      srcIn.start(now);
      crossGain.gain.linearRampToValueAtTime(1, now + fade);

      channel.currentSource = srcIn;
      channel.currentGain = crossGain;
      channel.currentIndex = index;
    }

    /* LFOs for lucid and astral frequency sweeps */
    startLFOs(){
      if(!this.audioContext){ return; }

      const floorVal = 0.1;
      const lfoRange = 1.0 - floorVal;

      const createLFOEnvelope = (freq)=>{
        const osc = this.audioContext.createOscillator(); osc.frequency.value = freq; osc.type = 'sine';
        const modulationGain = this.audioContext.createGain(); modulationGain.gain.value = lfoRange/2;
        osc.connect(modulationGain);
        const baseOffset = this.audioContext.createConstantSource(); baseOffset.offset.value = (lfoRange/2) + floorVal;
        osc.start(); baseOffset.start();
        return { modulationGainNode:modulationGain, baseOffsetNode:baseOffset };
      };

      this.lucidLFOComponents.groupA = createLFOEnvelope(1/160);
      this.lucidLFOComponents.groupB = createLFOEnvelope(1/245);

      this.orderedChannelNames.forEach(name=>{
        const ch = this.channels[name];
        const group = (name === 'sky' || name === 'fire') ? this.lucidLFOComponents.groupA : this.lucidLFOComponents.groupB;
        if(ch && ch.lucidControls && ch.lucidControls.wetMixGain && group){
          group.modulationGainNode.connect(ch.lucidControls.wetMixGain);
          group.baseOffsetNode.connect(ch.lucidControls.wetMixGain);
        }
      });

      const astralFreqs = [1/160, 1/140, 1/180, 1/120];
      this.orderedChannelNames.forEach((name, i)=>{
        const lfo = this.audioContext.createOscillator();
        const lfoGain = this.audioContext.createGain();
        const baseFreqNode = this.audioContext.createConstantSource();

        lfo.frequency.value = astralFreqs[i % astralFreqs.length];
        lfo.type = 'sine';
        lfoGain.gain.value = 6000;
        baseFreqNode.offset.value = 7000;

        lfo.connect(lfoGain);
        if(this.astralFilters[name] && this.astralFilters[name].frequency){
          lfoGain.connect(this.astralFilters[name].frequency);
          baseFreqNode.connect(this.astralFilters[name].frequency);
        }
        lfo.start(); baseFreqNode.start();
        this.astralLFOs[name] = { lfo, lfoGain, baseFreqNode };
      });
    }

    updateKnobColor(elementId, percentage){
      const knobImage = document.getElementById(elementId);
      if(!knobImage) return;
      const value = parseFloat(percentage)/100;
      const hueMinDeg = 0, hueMaxDeg = 180;
      const targetHue = hueMinDeg + (hueMaxDeg - hueMinDeg)*value;
      const brightness = 0.8 + 0.4*value;
      knobImage.style.filter = `hue-rotate(${targetHue}deg) saturate(1.5) brightness(${brightness})`;
    }

    fadeIn(gainParam, t, d=0.08){
      gainParam.cancelScheduledValues(t);
      gainParam.setValueAtTime(0, t);
      gainParam.linearRampToValueAtTime(1, t + d);
    }
    fadeOut(gainParam, t, d=0.08){
      gainParam.cancelScheduledValues(t);
      gainParam.setValueAtTime(gainParam.value, t);
      gainParam.linearRampToValueAtTime(0, t + d);
    }

    initializeEventListeners(){
      this.boundInitializeListener = async ()=>{
        if(!this.isInitialized){ await this.initialize(); }
        else if(this.audioContext && this.audioContext.state === 'suspended'){ await this.audioContext.resume(); }
      };
      document.addEventListener('click', this.boundInitializeListener, { once:true });

      const masterSlider = document.getElementById('masterSlider');
      const masterReadout = document.getElementById('masterReadout');
      masterSlider.addEventListener('input', (e)=>{
        if(!this.isInitialized || !this.masterGain) return;
        const t = this.audioContext.currentTime;
        const g = this.gainFromSlider(parseFloat(e.target.value));
        this.masterGain.gain.setTargetAtTime(g, t, 0.015);
        masterReadout.textContent = e.target.value;
        this.updateKnobColor('masterKnob', parseFloat(e.target.value));
      });

      const astralSlider = document.getElementById('astralSlider');
      const astralReadout = document.getElementById('astralReadout');
      astralSlider.addEventListener('input', (e)=>{
        if(!this.isInitialized) return;
        const value = parseFloat(e.target.value)/100;
        this.orderedChannelNames.forEach(n=>{
          const ch = this.channels[n];
          if(ch && ch.astralWetGain){
            ch.astralWetGain.gain.setTargetAtTime(value, this.audioContext.currentTime, 0.015);
          }
        });
        astralReadout.textContent = e.target.value;
        this.updateKnobColor('astralKnob', parseFloat(e.target.value));
      });

      const lucidSlider = document.getElementById('lucidSlider');
      const lucidReadout = document.getElementById('lucidReadout');
      lucidSlider.addEventListener('input', (e)=>{
        if(!this.isInitialized) return;
        const L = parseFloat(e.target.value)/100;
        this.orderedChannelNames.forEach(n=>{
          const ch = this.channels[n];
          if(ch && ch.lucidControls){
            ch.lucidControls.dryMixGain.gain.setTargetAtTime(1 - L, this.audioContext.currentTime, 0.015);
            ch.lucidControls.wetMixGain.gain.setTargetAtTime(L, this.audioContext.currentTime, 0.015);
          }
        });
        lucidReadout.textContent = e.target.value;
        this.updateKnobColor('lucidKnob', parseFloat(e.target.value));
      });

      this.orderedChannelNames.forEach(channelName=>{
        const slider = document.getElementById(`${channelName}Slider`);
        const readout = document.getElementById(`${channelName}Readout`);
        const spinner = document.getElementById(`${channelName}Spinner`);

        slider.addEventListener('input', (e)=>{
          if(!this.isInitialized) return;
          const v = this.gainFromSlider(parseFloat(e.target.value));
          if(this.channels[channelName] && this.channels[channelName].gain){
            this.channels[channelName].gain.gain.setTargetAtTime(v, this.audioContext.currentTime, 0.015);
          }
          readout.textContent = e.target.value;
          this.updateKnobColor(`${channelName}Knob`, parseFloat(e.target.value));
        });

        spinner.addEventListener('change', (e)=>{
          if(!this.isInitialized) return;
          const index = parseInt(e.target.value, 10);
          this.switchChannelSound(channelName, index);
        });
      });

      document.getElementById('saveButton').addEventListener('click', ()=> this.saveState());
      document.getElementById('loadButton').addEventListener('click', ()=> this.loadState());
    }

    saveState(){
      if(!this.isInitialized){ return; }
      const state = {
        master: document.getElementById('masterSlider').value,
        astral: document.getElementById('astralSlider').value,
        lucid: document.getElementById('lucidSlider').value,
        channels: {}
      };
      this.orderedChannelNames.forEach(n=>{
        state.channels[n] = {
          volume: document.getElementById(`${n}Slider`).value,
          selection: document.getElementById(`${n}Spinner`).value
        };
      });
      localStorage.setItem('slumbr_state_v5', JSON.stringify(state));
    }

    loadState(){
      if(!this.isInitialized){ return; }
      const saved = localStorage.getItem('slumbr_state_v5');
      let s = null;
      if(saved){ try{ s = JSON.parse(saved);}catch{} }

      if(!s){
        s = {
          master: document.getElementById('masterSlider').value,
          astral: document.getElementById('astralSlider').value,
          lucid: document.getElementById('lucidSlider').value,
          channels: {}
        };
        this.orderedChannelNames.forEach(n=>{
          s.channels[n] = {
            volume: document.getElementById(`${n}Slider`).value,
            selection: document.getElementById(`${n}Spinner`).value
          };
        });
      }

      // Apply by dispatching existing handlers
      document.getElementById('masterSlider').value = s.master;
      document.getElementById('masterSlider').dispatchEvent(new Event('input', { bubbles:true }));

      document.getElementById('astralSlider').value = s.astral;
      document.getElementById('astralSlider').dispatchEvent(new Event('input', { bubbles:true }));

      document.getElementById('lucidSlider').value = s.lucid;
      document.getElementById('lucidSlider').dispatchEvent(new Event('input', { bubbles:true }));

      if(s.channels){
        this.orderedChannelNames.forEach(n=>{
          const cs = s.channels[n];
          if(!cs) return;
          document.getElementById(`${n}Slider`).value = cs.volume;
          document.getElementById(`${n}Slider`).dispatchEvent(new Event('input', { bubbles:true }));

          document.getElementById(`${n}Spinner`).value = cs.selection;
          document.getElementById(`${n}Spinner`).dispatchEvent(new Event('change', { bubbles:true }));
        });
      }
    }

    async requestWakeLock(){
      if('wakeLock' in navigator){
        try{
          this.wakeLock = await navigator.wakeLock.request('screen');
          this.wakeLock.addEventListener('release', ()=>{ /* silently reacquire on visibility */ });
          document.addEventListener('visibilitychange', async ()=>{
            if(document.visibilityState === 'visible'){
              try{ this.wakeLock = await navigator.wakeLock.request('screen'); }catch{}
            }
          });
        }catch{}
      }
    }
  }

  const slumbr = new SlumbrApp();

  window.addEventListener('beforeunload', ()=>{
    if(slumbr.isInitialized){ slumbr.saveState(); }
  });

  // Register SW for offline use
  if('serviceWorker' in navigator){
    window.addEventListener('load', ()=>{ navigator.serviceWorker.register('./sw.js').catch(()=>{}); });
  }
  </script>

  <div style="text-align:center; margin-top:20px;">
    <a href="https://mikewhyle.com/ai/" target="_blank" rel="noopener">
      <img src="ad-mikewhyle-ai-consultant.png" alt="AI Consultant" style="max-width:100%; height:auto;">
    </a>
  </div>
</body>
</html>
