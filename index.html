<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>SLUMBR</title>

  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#101020">
  <link rel="icon" type="image/png" href="astral_knob.png"/>

  <style>
    *{ margin:0; padding:0; box-sizing:border-box; }
    body{
      font-family:Arial, sans-serif;
      background:#1a1a2e;
      color:white;
      user-select:none;
      overflow-x:hidden;
      overflow-y:auto;
      min-height:100vh;
      padding:0 12px 32px;
    }

    .app-container{
      position:relative;
      width:min(540px, 92vw);
      aspect-ratio:540 / 835;
      height:auto;
      margin:clamp(12px, 4vh, 28px) auto;
      max-height:calc(100vh - 64px);
    }
    @supports not (aspect-ratio: 1){
      .app-container{ height:835px; }
    }

    .layer-switcher{
      position:absolute; top:clamp(36px, 10%, 72px); left:50%; transform:translateX(-50%);
      display:flex; gap:10px; z-index:25;
    }
    .layer-dot{
      width:14px; height:14px; border-radius:50%; border:1px solid rgba(255,255,255,0.5);
      background:rgba(0,0,0,0.7); cursor:pointer; transition:transform 0.1s ease, box-shadow 0.2s ease;
      position:relative;
    }
    .layer-dot::after{
      content:""; position:absolute; inset:3px; border-radius:50%; background:rgba(255,255,255,0.2);
      transition:opacity 0.2s ease, background 0.25s ease;
      opacity:0;
    }
    .layer-dot.active{ box-shadow:0 0 6px rgba(120,180,255,0.7); transform:scale(1.08); }
    .layer-dot.active::after{ opacity:1; background:rgba(255,255,255,0.7); }
    .layer-dot:hover{ transform:scale(1.08); }

    .layer-stack{ position:absolute; inset:0; border-radius:12px; overflow:hidden; }
    .slumbr-layer{ position:absolute; inset:0; display:none; }
    .slumbr-layer.is-active{ display:block; }

    .layer-surface{
      position:relative; width:100%; height:100%;
      background-image:url('backgroundlatest.png');
      background-size:100% 100%;
      background-position:center;
      background-repeat:no-repeat;
    }

    .layer-surface::after{
      content:""; position:absolute; inset:0; pointer-events:none; border:1px solid rgba(255,255,255,0.08); border-radius:12px;
    }

    .layer-badge{
      position:absolute; top:24px; left:26px; background:rgba(0,0,0,0.48); padding:4px 10px; border-radius:999px;
      font-size:10px; letter-spacing:0.1em; text-transform:uppercase; opacity:0.75; pointer-events:none;
    }

    .tintOverlay{
      position:absolute; inset:0; pointer-events:none;
      background:rgba(0,0,0,0);
      transition:background-color 0.6s ease;
      mix-blend-mode: overlay;
      border-radius:12px;
    }

    .channel{
      position:absolute;
      display:flex;
      flex-direction:column;
      align-items:center;
      width:95px;
      height:240px;
      padding:4px;
      transform:translate(-50%, -50%);
    }
    .knob-container{
      position:relative;
      width:75px;
      height:75px;
      touch-action:none;
    }
    .knob-slider{ position:absolute; width:100%; height:100%; opacity:0; cursor:pointer; z-index:2; margin:0; }
    .knob-image{
      position:absolute;
      width:100%;
      height:100%;
      background-size:contain;
      background-repeat:no-repeat;
      background-position:center;
      pointer-events:none;
      filter:hue-rotate(180deg) saturate(1.5);
      transition:filter 0.1s ease, transform 0.1s ease;
      transform:rotate(var(--knob-angle, -135deg));
    }
    .knob-readout{ width:75px; height:24px; text-align:center; font-size:12px; color:white; line-height:24px; margin-top:2px; }

    .channel-spinner{
      width:90px; height:36px; background:transparent; border:1.5px solid rgba(58,137,255,0.4); border-radius:8px;
      color:white; font-size:18px; text-align:center; text-align-last:center; cursor:pointer; padding:0 4px;
      -webkit-appearance:none; -moz-appearance:none; appearance:none;
    }
    .channel-spinner:focus{ outline:none; border-color:rgba(58,137,255,0.8); }
    select.channel-spinner option{ background:#1f1f3d; color:white; font-size:16px; }
    select.channel-spinner option:hover{ background:#3c3c5d; }

    .control-knob{
      position:absolute;
      display:flex;
      flex-direction:column;
      align-items:center;
      transform:translate(-50%, -50%);
    }
    .control-knob.small .knob-container{ width:50px; height:50px; }
    .control-knob.small .knob-readout{ width:50px; font-size:10px; height:18px; line-height:18px; margin-top:2px; }
    .control-knob.large .knob-container{ width:150px; height:150px; }
    .control-knob.large .knob-readout{ width:150px; font-size:14px; height:24px; line-height:24px; margin-top:2px; }

    .save-load-buttons{
      position:absolute;
      bottom:8px;
      left:50%;
      transform:translateX(-50%);
      display:flex;
      gap:16px;
      align-items:center;
      justify-content:center;
    }
    .save-load-button{
      width:80px;
      height:80px;
      background:rgba(255,255,255,0.04);
      border:1px solid rgba(255,255,255,0.18);
      box-shadow:0 4px 14px rgba(0,0,0,0.25);
      color:white;
      font-size:14px;
      letter-spacing:0.08em;
      text-transform:uppercase;
      cursor:pointer;
      padding:10px;
      border-radius:12px;
      transition:background-color 0.2s ease, transform 0.12s ease;
      touch-action:manipulation;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      position:relative;
    }
    .save-load-button:hover{ background:rgba(255,255,255,0.12); transform:translateY(-2px); }
    .save-load-button:active{ transform:translateY(0); }
    .save-load-button.randomize{
      background:rgba(255,255,255,0.05) url('random.png') center/40px 40px no-repeat;
      border:1px solid rgba(255,255,255,0.22);
      box-shadow:0 4px 14px rgba(0,0,0,0.25);
    }
    .save-load-button.randomize:hover{
      background:rgba(255,255,255,0.16) url('random.png') center/40px 40px no-repeat;
    }
    .save-load-button.randomize:active{
      transform:scale(0.97);
    }
    .save-load-button::after{
      content:attr(data-label);
      font-size:11px;
      letter-spacing:0.14em;
      opacity:0.82;
      margin-bottom:2px;
    }
    .save-load-button.load{
      background:rgba(255,255,255,0.05) url('load.png') center 28px/34px 34px no-repeat;
    }
    .save-load-button.load:hover{
      background:rgba(255,255,255,0.14) url('load.png') center 28px/34px 34px no-repeat;
    }
    .save-load-button.save{
      background:rgba(255,255,255,0.05) url('save.png') center 28px/34px 34px no-repeat;
    }
    .save-load-button.save:hover{
      background:rgba(255,255,255,0.14) url('save.png') center 28px/34px 34px no-repeat;
    }

    .eq-buttons{ position:absolute; bottom:100px; left:50%; transform:translateX(-50%); display:flex; gap:6px; align-items:center; justify-content:center; }
    .eq-button{
      width:16px; height:16px; border-radius:50%;
      border:1px solid rgba(255,255,255,0.5); background:transparent; cursor:pointer;
      box-shadow:0 0 0 0 rgba(0,0,0,0) inset;
      transition: box-shadow 0.2s ease, transform 0.05s ease;
    }
    .eq-button:active{ transform: scale(0.96); }
    .eq-button.active{ box-shadow:0 0 0 2px rgba(255,255,255,0.45) inset; }

    .eq-white{ background: rgba(255,255,255,0.28); }
    .eq-pink { background: rgba(255,105,180,0.32); }
    .eq-green{ background: rgba(46,204,113,0.32); }
    .eq-brown{ background: rgba(165,94,41,0.32); }
    .eq-black{ background: rgba(20,24,30,0.55); }

    .channel.sky{ left:28%; top:58%; }
    .channel.fire{ left:74%; top:58%; }
    .channel.earth{ left:27%; top:82%; }
    .channel.sea{ left:73%; top:82%; }
    .control-knob.astral{ left:38%; top:30%; }
    .control-knob.lucid{ left:62%; top:30%; }
    .control-knob.master{ left:50%; top:66%; }

    .channel-content{ display:flex; flex-direction:column; align-items:center; justify-content:center; gap:4px; width:100%; }
    .channel.earth .channel-content > .channel-spinner,
    .channel.sea  .channel-content > .channel-spinner{ order:1; }
    .channel.earth .channel-content > .knob-container,
    .channel.sea  .channel-content > .knob-container{ order:2; }
    .channel.earth .channel-content > .knob-readout,
    .channel.sea  .channel-content > .knob-readout{ order:3; }
    .channel.sky .channel-content > .knob-container,
    .channel.fire .channel-content > .knob-container{ order:1; }
    .channel.sky .channel-content > .knob-readout,
    .channel.fire .channel-content > .knob-readout{ order:2; }
    .channel.sky .channel-content > .channel-spinner,
    .channel.fire .channel-content > .channel-spinner{ order:3; }

    .loading-indicator{
      position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      color:white; font-size:18px; text-align:center; padding:20px; background-color:rgba(0,0,0,0.5); border-radius:8px;
      cursor:pointer;
      touch-action:manipulation;
    }
    .progress{ margin-top:12px; width:260px; height:6px; background:rgba(255,255,255,0.15); border-radius:3px; overflow:hidden; }
    .progress-bar{ height:100%; width:0%; background:#2ecc71; transition:width 0.2s ease; }

    .layer-theme-blue .layer-surface{ filter:hue-rotate(-12deg) saturate(1.08); }
    .layer-theme-green .layer-surface{ filter:hue-rotate(28deg) saturate(1.05); }
    .layer-theme-red .layer-surface{ filter:hue-rotate(-58deg) saturate(1.12); }

    @media (max-width:560px){
      body{ padding:0 6px 24px; }
      .app-container{
        width:100%;
        max-width:420px;
        margin:clamp(8px, 4vh, 20px) auto;
        max-height:none;
      }
      .layer-switcher{ top:clamp(24px, 11vw, 48px); }
      .control-knob.master{ top:68%; }
      .channel.sky{ top:56%; }
      .channel.fire{ top:56%; }
      .channel.earth{ top:84%; }
      .channel.sea{ top:84%; }
    }

    .tour-overlay[hidden]{ display:none; }
    .tour-overlay{
      position:fixed;
      inset:0;
      z-index:1000;
      background:rgba(9,12,24,0.68);
      padding:16px;
      backdrop-filter:blur(6px);
    }
    .tour-card{
      position:absolute;
      max-width:320px;
      width:100%;
      background:rgba(18,26,46,0.92);
      border:1px solid rgba(255,255,255,0.18);
      border-radius:16px;
      padding:18px 20px 52px;
      color:#f5f7ff;
      box-shadow:0 18px 60px rgba(0,0,0,0.45);
    }
    .tour-card h3{
      font-size:17px;
      margin-bottom:8px;
      letter-spacing:0.04em;
    }
    .tour-card p{
      font-size:14px;
      line-height:1.5;
      color:rgba(235,240,255,0.88);
    }
    .tour-controls{
      display:flex;
      justify-content:space-between;
      position:absolute;
      bottom:14px;
      left:20px;
      right:20px;
      gap:8px;
    }
    .tour-controls button{
      flex:1;
      padding:10px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.2);
      background:rgba(255,255,255,0.05);
      color:white;
      font-size:13px;
      letter-spacing:0.05em;
      cursor:pointer;
      transition:background 0.2s ease, transform 0.12s ease;
    }
    .tour-controls button:hover{ background:rgba(255,255,255,0.16); transform:translateY(-1px); }
    .tour-controls button:active{ transform:translateY(0); }
    .tour-controls button:disabled{
      opacity:0.45;
      cursor:default;
      transform:none;
      background:rgba(255,255,255,0.05);
    }
    .tour-pointer{
      position:absolute;
      width:0;
      height:0;
      border:14px solid transparent;
      border-bottom-color:rgba(18,26,46,0.92);
      top:-26px;
      left:calc(50% - 14px);
    }
    .tour-pointer.bottom{
      top:auto;
      bottom:-26px;
      border-bottom-color:transparent;
      border-top-color:rgba(18,26,46,0.92);
    }
    .tour-highlight{
      z-index:1100 !important;
      box-shadow:0 0 0 2px rgba(120,180,255,0.7), 0 0 30px rgba(120,180,255,0.45);
      border-radius:16px;
    }
  </style>
</head>
<body>
  <div class="app-container">
    <div class="layer-switcher" role="tablist" aria-label="Sound layer selector">
      <button class="layer-dot active" data-index="0" aria-label="Aurora layer"></button>
      <button class="layer-dot" data-index="1" aria-label="Verdant layer"></button>
      <button class="layer-dot" data-index="2" aria-label="Crimson layer"></button>
    </div>
    <div id="layerStack" class="layer-stack"></div>
  </div>

  <div class="tour-overlay" data-id="tourOverlay" hidden>
    <div class="tour-card" data-id="tourCard">
      <div class="tour-pointer" data-id="tourPointer"></div>
      <h3 data-id="tourTitle"></h3>
      <p data-id="tourCopy"></p>
      <div class="tour-controls">
        <button type="button" data-id="tourPrev">Prev</button>
        <button type="button" data-id="tourNext">Next</button>
        <button type="button" data-id="tourDismiss">Dismiss</button>
      </div>
    </div>
  </div>

  <template id="slumbrLayerTemplate">
    <div class="slumbr-layer">
      <div class="layer-surface">
        <div class="layer-badge" data-id="layerBadge">Layer</div>
        <div class="tintOverlay" data-id="tintOverlay" aria-hidden="true"></div>

        <div class="loading-indicator" data-id="loadingIndicator" aria-live="polite">
          <div data-id="loadingText">Start SLUMBR</div>
          <div class="progress" aria-hidden="true">
            <div class="progress-bar" data-id="progressBar" style="width:0%"></div>
          </div>
        </div>

        <div class="control-knob astral small">
          <div class="knob-container small">
            <input type="range" min="0" max="100" value="60" class="knob-slider small" data-id="astralSlider" aria-label="Astral wet amount">
            <div class="knob-image small" data-id="astralKnob" style="background-image:url('astral_knob.png');" role="img" aria-label="Astral control"></div>
          </div>
          <div class="knob-readout" data-id="astralReadout" aria-live="polite">60</div>
        </div>

        <div class="control-knob lucid small">
          <div class="knob-container small">
            <input type="range" min="0" max="100" value="60" class="knob-slider small" data-id="lucidSlider" aria-label="Lucid modulation depth">
            <div class="knob-image small" data-id="lucidKnob" style="background-image:url('lucid_knob.png');" role="img" aria-label="Lucid control"></div>
          </div>
          <div class="knob-readout" data-id="lucidReadout" aria-live="polite">60</div>
        </div>

        <div class="channel sky">
          <div class="channel-content">
            <div class="knob-container">
              <input type="range" min="0" max="100" value="50" class="knob-slider" data-id="skySlider" aria-label="Sky channel volume">
              <div class="knob-image" data-id="skyKnob" style="background-image:url('sky_knob.png');" role="img" aria-label="Sky channel knob"></div>
            </div>
            <div class="knob-readout" data-id="skyReadout" aria-live="polite">50</div>
            <select class="channel-spinner" data-id="skySpinner" aria-label="Sky sound">
              <option value="0">Tempest</option><option value="1">Breeze</option><option value="2">Balmy</option>
              <option value="3">Temple</option><option value="4">Rain</option><option value="5">Mountains</option><option value="6">Spring</option>
            </select>
          </div>
        </div>

        <div class="channel fire">
          <div class="channel-content">
            <div class="knob-container">
              <input type="range" min="0" max="100" value="50" class="knob-slider" data-id="fireSlider" aria-label="Fire channel volume">
              <div class="knob-image" data-id="fireKnob" style="background-image:url('fire_knob.png');" role="img" aria-label="Fire channel knob"></div>
            </div>
            <div class="knob-readout" data-id="fireReadout" aria-live="polite">50</div>
            <select class="channel-spinner" data-id="fireSpinner" aria-label="Fire sound">
              <option value="0">Hearth</option><option value="1">Forge</option><option value="2">Ember</option>
              <option value="3">Crackle</option><option value="4">Campfire</option><option value="5">Summer</option><option value="6">Desert</option>
            </select>
          </div>
        </div>

        <div class="control-knob master large">
          <div class="knob-container large">
            <input type="range" min="0" max="100" value="40" class="knob-slider large" data-id="masterSlider" aria-label="Master volume">
            <div class="knob-image large" data-id="masterKnob" style="background-image:url('master_knob.png');" role="img" aria-label="Master knob"></div>
          </div>
          <div class="knob-readout" data-id="masterReadout" aria-live="polite">40</div>
        </div>

        <div class="channel earth">
          <div class="channel-content">
            <select class="channel-spinner" data-id="earthSpinner" aria-label="Earth sound">
              <option value="0">Kiln</option><option value="1">Magma</option><option value="2">Crevasse</option>
              <option value="3">Core</option><option value="4">Forest</option><option value="5">Autumn</option><option value="6">Cave</option>
            </select>
            <div class="knob-container">
              <input type="range" min="0" max="100" value="50" class="knob-slider" data-id="earthSlider" aria-label="Earth channel volume">
              <div class="knob-image" data-id="earthKnob" style="background-image:url('earth_knob.png');" role="img" aria-label="Earth channel knob"></div>
            </div>
            <div class="knob-readout" data-id="earthReadout" aria-live="polite">50</div>
          </div>
        </div>

        <div class="channel sea">
          <div class="channel-content">
            <select class="channel-spinner" data-id="seaSpinner" aria-label="Sea sound">
              <option value="0">Stormy</option><option value="1">Brook</option><option value="2">Winter</option>
              <option value="3">Lake</option><option value="4">Deep</option><option value="5">Glade</option><option value="6">Creek</option>
            </select>
            <div class="knob-container">
              <input type="range" min="0" max="100" value="50" class="knob-slider" data-id="seaSlider" aria-label="Sea channel volume">
              <div class="knob-image" data-id="seaKnob" style="background-image:url('sea_knob.png');" role="img" aria-label="Sea channel knob"></div>
            </div>
            <div class="knob-readout" data-id="seaReadout" aria-live="polite">50</div>
          </div>
        </div>

        <div class="eq-buttons" aria-label="EQ presets">
          <button class="eq-button eq-white active" data-id="eqWhite" title="White EQ" aria-label="White EQ"></button>
          <button class="eq-button eq-pink"  data-id="eqPink"  title="Pink EQ"  aria-label="Pink EQ"></button>
          <button class="eq-button eq-green" data-id="eqGreen" title="Green EQ" aria-label="Green EQ"></button>
          <button class="eq-button eq-brown" data-id="eqBrown" title="Brown EQ" aria-label="Brown EQ"></button>
          <button class="eq-button eq-black" data-id="eqBlack" title="Black EQ" aria-label="Black EQ"></button>
        </div>

        <div class="save-load-buttons">
          <button class="save-load-button load" data-id="loadButton" data-label="LOAD" aria-label="Load preset" type="button"></button>
          <button class="save-load-button randomize" data-id="randomizeButton" data-label="RND" aria-label="Randomize preset" type="button"></button>
          <button class="save-load-button save" data-id="saveButton" data-label="SAVE" aria-label="Save preset" type="button"></button>
        </div>
      </div>
    </div>
  </template>

  <script>
  const AUDIO_PRELOAD_CORE_COUNT = 3;
  const SharedAudioCache = {
    _promises:new Map(),
    async fetch(url){
      if(!this._promises.has(url)){
        this._promises.set(url, fetch(url).then(resp=>{
          if(!resp.ok){ throw new Error(`HTTP ${resp.status} for ${url}`); }
          return resp.arrayBuffer();
        }));
      }
      return this._promises.get(url);
    }
  };

  class SlumbrLayer {
    constructor(root, index, options={}){
      this.root = root;
      this.index = index;
      this.options = options;
      this.audioContext = null;
      this.isInitialized = false;

      this.channels = {};
      this.masterGain = null;
      this.eq = null;
      this.limiter = null;

      this.lucidLFOComponents = {};
      this.astralLFOs = {};
      this.astralFilters = {};

      this.wakeLock = null;

      this.eqMode = 'white';
      this.startEvents = ['pointerdown','touchstart','click'];
      this.suppressUserStartCallback = false;
      this.initializingPromise = null;
      this.eqTintMap = {
        white:{ r:255, g:255, b:255, weight:0.18 },
        pink: { r:255, g:120, b:200, weight:0.42 },
        green:{ r:46,  g:204, b:113, weight:0.42 },
        brown:{ r:165, g:94,  b:41,  weight:0.42 },
        black:{ r:24,  g:28,  b:36,  weight:0.55 }
      };

      this.INITIAL_SETTINGS = {
        master: 0.40,
        sky: 0.50,
        fire: 0.50,
        earth: 0.50,
        sea: 0.50,
        astral: 0.60,
        lucid: 0.60
      };

      /* A/B pairing maps */
      this.channelData = {
        sky: {
          files:['sky1.ogg','sky2.ogg','sky3.ogg','sky4.ogg','sky5.ogg','sky6.ogg','sky7.ogg'],
          labels:['Tempest','Breeze','Balmy','Temple','Rain','Mountains','Spring'],
          initialVolume:this.INITIAL_SETTINGS.sky, pan:+0.40,
          abMap:{ 0:3, 1:4, 2:5, 3:0, 4:1, 5:6, 6:2 }
        },
        fire:{
          files:['fire1.ogg','fire2.ogg','fire3.ogg','fire4.ogg','fire5.ogg','fire6.ogg','fire7.ogg'],
          labels:['Hearth','Forge','Ember','Crackle','Campfire','Summer','Desert'],
          initialVolume:this.INITIAL_SETTINGS.fire, pan:-0.50,
          abMap:{ 0:6, 1:2, 2:5, 3:0, 4:1, 5:3, 6:4 }
        },
        earth:{
          files:['earth1.ogg','earth2.ogg','earth3.ogg','earth4.ogg','earth5.ogg','earth6.ogg','earth7.ogg'],
          labels:['Kiln','Magma','Crevasse','Core','Forest','Autumn','Cave'],
          initialVolume:this.INITIAL_SETTINGS.earth, pan:-0.30,
          abMap:{ 0:6, 1:4, 2:5, 3:1, 4:2, 5:0, 6:3 }
        },
        sea:{
          files:['sea1.ogg','sea2.ogg','sea3.ogg','sea4.ogg','sea5.ogg','sea6.ogg','sea7.ogg'],
          labels:['Stormy','Brook','Winter','Lake','Deep','Glade','Creek'],
          initialVolume:this.INITIAL_SETTINGS.sea, pan:+0.60,
          abMap:{ 0:3, 1:4, 2:6, 3:0, 4:1, 5:2, 6:5 }
        }
      };
      this.orderedChannelNames = ['sky','fire','earth','sea'];

      this.layerTintBias = options.baseTint || null;
      this.layerTintBiasWeight = options.baseTintWeight ?? 0.2;

      this.preloadCount = AUDIO_PRELOAD_CORE_COUNT;
      this.loadingStats = {
        total: this.computeTotalSampleCount(),
        done: 0
      };
      this.coreLoadTarget = this.preloadCount * this.orderedChannelNames.length;
      this.pendingChannelSelections = {};

      this.prepareChannelSpinners();
      this.initializeEventListeners();
      if(this.el('layerBadge') && options.label){ this.el('layerBadge').textContent = options.label; }
      if(this.el('loadingText') && options.startText){ this.el('loadingText').textContent = options.startText; }
      this.refreshInitialKnobColours();
      this.attachKnobInteractions();
    }

    el(id){ return this.root.querySelector(`[data-id="${id}"]`); }
    els(selector){ return Array.from(this.root.querySelectorAll(selector)); }

    computeTotalSampleCount(){
      return this.orderedChannelNames.reduce((acc, name)=>{
        const files = this.channelData[name]?.files || [];
        return acc + files.length;
      }, 0);
    }

    prepareChannelSpinners(){
      this.orderedChannelNames.forEach(name=>{
        const spinner = this.el(`${name}Spinner`);
        const data = this.channelData[name];
        if(!spinner || !data) return;
        spinner.innerHTML = '';
        data.labels.forEach((label, index)=>{
          const option = document.createElement('option');
          option.value = String(index);
          option.dataset.index = String(index);
          option.dataset.label = label;
          option.textContent = index < this.preloadCount ? label : `${label} • loading…`;
          if(index >= this.preloadCount){ option.disabled = true; option.dataset.loading = 'true'; }
          spinner.appendChild(option);
        });
        spinner.value = '0';
      });
    }

    enableSpinnerOptions(channelName, indices){
      const spinner = this.el(`${channelName}Spinner`);
      const labels = this.channelData[channelName]?.labels || [];
      if(!spinner) return;
      const options = Array.from(spinner.options);
      indices.forEach(index=>{
        const option = options.find(opt=> parseInt(opt.value, 10) === index);
        if(option){
          option.disabled = false;
          option.dataset.loading = 'false';
          option.textContent = option.dataset.label || labels[index] || option.textContent;
        }
      });
    }

    applyPendingSelectionIfReady(channelName, index){
      const pending = this.pendingChannelSelections[channelName];
      if(typeof pending !== 'number' || pending !== index){ return; }
      const spinner = this.el(`${channelName}Spinner`);
      if(spinner){
        spinner.value = String(index);
        spinner.dispatchEvent(new Event('change', { bubbles:true }));
      }else{
        this.switchChannelSound(channelName, index);
      }
      delete this.pendingChannelSelections[channelName];
    }

    attachKnobInteractions(){
      const containers = this.els('.knob-container');
      containers.forEach(container=>{
        if(container.dataset.knobReady){ return; }
        const slider = container.querySelector('.knob-slider');
        const image  = container.querySelector('.knob-image');
        if(!slider || !image) return;

        const updateAngleFromValue = ()=>{
          const min = parseFloat(slider.min || '0');
          const max = parseFloat(slider.max || '100');
          const value = parseFloat(slider.value || '0');
          const percent = (value - min) / Math.max(1, (max - min));
          const angleRange = 270;
          const angle = -135 + percent * angleRange;
          image.style.setProperty('--knob-angle', `${angle}deg`);
          image.style.transform = `rotate(${angle}deg)`;
        };

        let pointerState = null;
        const sensitivity = container.classList.contains('large') ? 0.12 : 0.18;

        const clampValue = (v)=>{
          const min = parseFloat(slider.min || '0');
          const max = parseFloat(slider.max || '100');
          return Math.max(min, Math.min(max, v));
        };

        const commitValue = (v, dispatchEvent = true)=>{
          slider.value = String(clampValue(v));
          if(dispatchEvent){ slider.dispatchEvent(new Event('input', { bubbles:true })); }
        };

        container.addEventListener('pointerdown', (event)=>{
          if(event.button !== 0 && event.pointerType !== 'touch'){ return; }
          container.setPointerCapture(event.pointerId);
          pointerState = {
            pointerId: event.pointerId,
            startX: event.clientX,
            startY: event.clientY,
            startValue: parseFloat(slider.value || '0')
          };
          slider.focus({ preventScroll:true });
          event.preventDefault();
        });

        container.addEventListener('pointermove', (event)=>{
          if(!pointerState || pointerState.pointerId !== event.pointerId) return;
          const deltaY = pointerState.startY - event.clientY;
          const deltaX = event.clientX - pointerState.startX;
          const delta = deltaY + deltaX*0.35;
          const next = pointerState.startValue + delta * sensitivity;
          commitValue(next, true);
        });

        const releasePointer = (event)=>{
          if(!pointerState || pointerState.pointerId !== event.pointerId) return;
          container.releasePointerCapture(event.pointerId);
          pointerState = null;
          slider.dispatchEvent(new Event('change', { bubbles:true }));
        };

        container.addEventListener('pointerup', releasePointer);
        container.addEventListener('pointercancel', releasePointer);

        container.addEventListener('wheel', (event)=>{
          event.preventDefault();
          const delta = event.deltaY > 0 ? -1 : 1;
          const step = slider.step ? parseFloat(slider.step) : 1;
          const next = parseFloat(slider.value || '0') + delta * step * 2;
          commitValue(next, true);
        }, { passive:false });

        slider.addEventListener('input', updateAngleFromValue);
        updateAngleFromValue();
        container.dataset.knobReady = 'true';
      });
    }

    gainFromSlider(v){ return Math.pow(v/100, 2.2); }
    randBetween(min,max){ return min + Math.random()*(max-min); }
    randomInt(min, max){ return Math.floor(Math.random()*(max - min + 1)) + min; }

    removeStartListeners(){
      if(!this.startEvents || !this.boundInitializeListener) return;
      this.startEvents.forEach(evt=>{
        this.root.removeEventListener(evt, this.boundInitializeListener);
      });
    }

    addStartListeners(){
      if(!this.startEvents || !this.boundInitializeListener) return;
      this.startEvents.forEach(evt=>{
        const options = evt === 'click' ? false : { passive:true };
        this.root.addEventListener(evt, this.boundInitializeListener, options);
      });
    }

    async externalInitialize(){
      if(this.isInitialized) return;
      this.suppressUserStartCallback = true;
      this.removeStartListeners();
      try{
        await this.initialize();
      }catch(err){
        console.error(`Failed to initialize layer ${this.index}:`, err);
      }finally{
        this.suppressUserStartCallback = false;
      }
    }

    async initialize(){
      if(this.isInitialized) return;
      if(this.initializingPromise){ return this.initializingPromise; }

      const loadingIndicator = this.el('loadingIndicator');
      const runInitialization = async ()=>{
        try{
          if(!this.audioContext){
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          }
          if(this.audioContext.state === 'suspended'){ await this.audioContext.resume(); }
          if(this.audioContext.state !== 'running'){
            if(loadingIndicator){ loadingIndicator.textContent = 'AudioContext not running. Tap again.'; }
            this.addStartListeners();
            return;
          }

          this.setupAudioGraph();
          this.startLFOs();

          await this.loadCoreSounds();

          this.isInitialized = true;
          if(loadingIndicator){ loadingIndicator.style.display = 'none'; loadingIndicator.style.color = ''; }
          this.loadState();

          this.beginDeferredSoundLoading();

          this.requestWakeLock();
          this.updateTintOverlay();
          this.updatePanWidthFromAstral();
        }catch(err){
          console.error('Failed to initialize SLUMBR:', err);
          if(loadingIndicator){
            loadingIndicator.textContent = `Error: ${err.message}. Try refreshing.`;
            loadingIndicator.style.color = 'red';
          }
        }finally{
          this.initializingPromise = null;
        }
      };

      this.initializingPromise = runInitialization();
      return this.initializingPromise;
    }

    setupAudioGraph(){
      if(!this.audioContext){ return; }

      this.masterGain = this.audioContext.createGain();
      this.masterGain.gain.value = this.gainFromSlider(this.INITIAL_SETTINGS.master*100);

      const low = this.audioContext.createBiquadFilter(); low.type='lowshelf'; low.frequency.value = 200; low.gain.value = 0;
      const mid = this.audioContext.createBiquadFilter(); mid.type='peaking';  mid.frequency.value = 500; mid.Q.value = 0.7; mid.gain.value = 0;
      const high= this.audioContext.createBiquadFilter(); high.type='highshelf'; high.frequency.value = 2000; high.gain.value = 0;
      const dark= this.audioContext.createBiquadFilter(); dark.type='lowpass'; dark.frequency.value = 20000; dark.Q.value = 0.7;

      this.eq = { low, mid, high, dark };

      this.limiter = this.audioContext.createDynamicsCompressor();
      this.limiter.threshold.value = -1.0;
      this.limiter.knee.value = 12;
      this.limiter.ratio.value = 12;
      this.limiter.attack.value = 0.003;
      this.limiter.release.value = 0.08;

      this.masterGain.connect(low);
      low.connect(mid); mid.connect(high); high.connect(dark); dark.connect(this.limiter);
      this.limiter.connect(this.audioContext.destination);

      for(const channelName of this.orderedChannelNames){ this.setupChannelAudio(channelName); }

      this.setEQMode('white');
    }

    setEQMode(mode){
      if(!this.eq) return;
      const { low, mid, high, dark } = this.eq;

      low.gain.setValueAtTime(0, this.audioContext.currentTime);
      mid.gain.setValueAtTime(0, this.audioContext.currentTime);
      high.gain.setValueAtTime(0, this.audioContext.currentTime);
      dark.frequency.setValueAtTime(20000, this.audioContext.currentTime);

      if(mode === 'pink'){
        low.gain.value = +3; high.gain.value = -3; dark.frequency.value = 18000;
      } else if(mode === 'green'){
        mid.gain.value = +4; low.gain.value = -1; high.gain.value = -1; dark.frequency.value = 16000;
      } else if(mode === 'brown'){
        low.gain.value = +6; high.gain.value = -6; dark.frequency.value = 15000;
      } else if(mode === 'black'){
        low.gain.value = +4; high.gain.value = -10; dark.frequency.value = 6000;
      }

      ['White','Pink','Green','Brown','Black'].forEach(n=>{
        const el = this.el('eq'+n);
        if(el) el.classList.toggle('active', n.toLowerCase() === mode);
      });
      this.eqMode = mode;

      this.updateTintOverlay();
    }

    setupChannelAudio(channelName){
      const channel = {};
      this.channels[channelName] = channel;

      channel.gain = this.audioContext.createGain();
      channel.gain.gain.value = this.gainFromSlider(this.channelData[channelName].initialVolume*100);

      channel.lucidEffectGainNode = this.audioContext.createGain();
      channel.gain.connect(channel.lucidEffectGainNode);

      channel.astralFilter = this.audioContext.createBiquadFilter();
      channel.astralFilter.type = 'bandpass';
      channel.astralFilter.frequency.value = 7000;
      channel.astralFilter.Q.value = 1.2;

      channel.astralWetGain = this.audioContext.createGain();
      const astralSliderElement = this.el('astralSlider');
      channel.astralWetGain.gain.value = astralSliderElement ? parseFloat(astralSliderElement.value)/100 : this.INITIAL_SETTINGS.astral;

      channel.sum = this.audioContext.createGain();

      channel.pannerA = this.audioContext.createStereoPanner();
      channel.pannerB = this.audioContext.createStereoPanner();
      channel.pannerA.pan.value = 0;
      channel.pannerB.pan.value = 0;

      channel.panLFOfreqA = this.randBetween(1/30, 1/12);
      channel.panLFOfreqB = this.randBetween(1/30, 1/12);

      channel.panLFOA = this.audioContext.createOscillator();
      channel.panLFOA.type = 'sine';
      channel.panLFOA.frequency.value = channel.panLFOfreqA;

      channel.panLFOB = this.audioContext.createOscillator();
      channel.panLFOB.type = 'sine';
      channel.panLFOB.frequency.value = channel.panLFOfreqB;

      channel.panDepthA = this.audioContext.createGain();
      channel.panDepthB = this.audioContext.createGain();
      channel.panDepthA.gain.value = 0;
      channel.panDepthB.gain.value = 0;

      channel.panLFOA.connect(channel.panDepthA).connect(channel.pannerA.pan);
      channel.panLFOB.connect(channel.panDepthB).connect(channel.pannerB.pan);
      channel.panLFOA.start();
      channel.panLFOB.start();

      channel.pannerA.connect(channel.sum);
      channel.pannerB.connect(channel.sum);

      channel.lucidEffectGainNode.connect(this.masterGain);
      channel.lucidEffectGainNode.connect(channel.astralFilter);
      channel.astralFilter.connect(channel.astralWetGain);
      channel.astralWetGain.connect(this.masterGain);

      channel.sum.connect(channel.gain);

      this.astralFilters[channelName] = channel.astralFilter;

      const dcOneNode = this.audioContext.createConstantSource(); dcOneNode.offset.value = 1.0; dcOneNode.start();
      const lucidSliderElement = this.el('lucidSlider');
      const initialLucidValue = lucidSliderElement ? parseFloat(lucidSliderElement.value)/100 : this.INITIAL_SETTINGS.lucid;

      const dryMixGain = this.audioContext.createGain(); dryMixGain.gain.value = 1.0 - initialLucidValue;
      const wetMixGain = this.audioContext.createGain(); wetMixGain.gain.value = initialLucidValue;

      dcOneNode.connect(dryMixGain); dryMixGain.connect(channel.lucidEffectGainNode.gain);
      wetMixGain.connect(channel.lucidEffectGainNode.gain);
      channel.lucidControls = { dryMixGain, wetMixGain };

      channel.pair = null;
      channel.abDepth = 0;
      channel.abPhase = Math.random()*Math.PI*2;
      channel.abFreq  = 1 / (180 + Math.random()*120);
      channel.abTimer = null;
      channel.audioBuffers = new Array(this.channelData[channelName].files.length).fill(null);
      channel.loadingPromises = new Map();
      channel.loadedIndices = new Set();
      channel.currentIndex = null;
    }

    updateLoadingProgress(done = this.loadingStats?.done ?? 0, total = this.loadingStats?.total ?? 0){
      const text = this.el('loadingText');
      const bar  = this.el('progressBar');
      const pct  = total > 0 ? Math.round((done/total)*100) : 0;
      if(text){
        const phase = done < this.coreLoadTarget ? 'Priming essentials' : 'Layering ambience';
        text.textContent = `${phase} ${pct}%`;
      }
      if(bar)  bar.style.width   = `${pct}%`;
    }

    incrementLoadingProgress(){
      if(!this.loadingStats) return;
      this.loadingStats.done = Math.min(this.loadingStats.total, this.loadingStats.done + 1);
      this.updateLoadingProgress();
    }

    async loadCoreSounds(){
      this.updateLoadingProgress(0, this.loadingStats.total);
      for(const channelName of this.orderedChannelNames){
        await this.loadChannelCore(channelName);
      }
    }

    async loadChannelCore(channelName){
      const data = this.channelData[channelName];
      if(!data) return;
      const targetIndices = data.files.map((_, idx)=> idx).slice(0, this.preloadCount);
      for(const index of targetIndices){
        await this.ensureChannelBuffer(channelName, index);
      }
      this.enableSpinnerOptions(channelName, targetIndices);
      const spinner = this.el(`${channelName}Spinner`);
      if(spinner){
        const preferred = parseInt(spinner.value, 10) || 0;
        const fallback = targetIndices.includes(preferred) ? preferred : targetIndices[0] || 0;
        if(spinner.value !== String(fallback)){ spinner.value = String(fallback); }
        this.switchChannelSound(channelName, fallback);
      }
    }

    beginDeferredSoundLoading(){
      this.orderedChannelNames.forEach(channelName=>{
        const data = this.channelData[channelName];
        if(!data) return;
        const remaining = data.files.map((_, idx)=> idx).slice(this.preloadCount);
        if(!remaining.length) return;
        const run = async()=>{
          for(const index of remaining){
            await this.ensureChannelBuffer(channelName, index);
          }
        };
        run().catch(err=> console.warn(`Deferred load failed for ${channelName}`, err));
      });
    }

    async ensureChannelBuffer(channelName, index){
      const channel = this.channels[channelName];
      if(!channel) return null;
      if(channel.audioBuffers[index] && channel.audioBuffers[index].buffer){
        return channel.audioBuffers[index];
      }
      if(channel.loadingPromises.has(index)){
        return channel.loadingPromises.get(index);
      }
      const data = this.channelData[channelName];
      const file = data?.files?.[index];
      if(!file){ return null; }
      const url = `sounds/${file}`;

      const promise = SharedAudioCache.fetch(url)
        .then(arrayBuffer=> this.decodeArrayBuffer(arrayBuffer))
        .then(audioBuffer=> this.prepareBufferMeta(audioBuffer))
        .catch(err=>{
          console.warn(`Falling back to silence for ${url}`, err);
          return this.prepareBufferMeta(this.createSilentBuffer());
        })
        .then(meta=>{
          channel.audioBuffers[index] = meta;
          channel.loadedIndices.add(index);
          this.incrementLoadingProgress();
          this.enableSpinnerOptions(channelName, [index]);
          this.applyPendingSelectionIfReady(channelName, index);
          return meta;
        })
        .finally(()=>{
          channel.loadingPromises.delete(index);
        });

      channel.loadingPromises.set(index, promise);
      return promise;
    }

    async decodeArrayBuffer(arrayBuffer){
      if(!this.audioContext) throw new Error('AudioContext not ready');
      const copy = arrayBuffer.slice(0);
      return new Promise((resolve, reject)=>{
        this.audioContext.decodeAudioData(copy, resolve, reject);
      });
    }

    computeRMS(buf){
      const ch = buf.getChannelData(0);
      let sum = 0, n = 0, step = 128;
      for(let i=0;i<ch.length;i+=step){ const s = ch[i]; sum += s*s; n++; }
      return Math.sqrt(sum/Math.max(1,n));
    }

    prepareBufferMeta(audioBuffer){
      const rms = this.computeRMS(audioBuffer);
      const target = 0.16;
      const pregain = Math.min(4, Math.max(0.25, target/(rms + 1e-6)));
      return { buffer:audioBuffer, pregain };
    }

    createSilentBuffer(){
      if(!this.audioContext){ throw new Error('AudioContext not ready'); }
      return this.audioContext.createBuffer(1, Math.max(1, this.audioContext.sampleRate*0.02), this.audioContext.sampleRate);
    }

    getABIndex(channelName, index){
      const data = this.channelData[channelName];
      const map = data && data.abMap ? data.abMap : null;
      if(map && typeof map[index] !== 'undefined'){ return map[index]; }
      const len = data.files.length;
      return (index + 1) % len;
    }

    switchChannelSound(channelName, index){
      if(!this.isInitialized || !this.audioContext || this.audioContext.state !== 'running'){ return; }
      const ch = this.channels[channelName];
      if(!ch){ return; }
      if(!ch.loadedIndices.has(index)){
        this.pendingChannelSelections[channelName] = index;
        this.ensureChannelBuffer(channelName, index).catch(()=>{});
        return;
      }
      const metaA = ch.audioBuffers[index];
      if(!metaA || !metaA.buffer || metaA.buffer.duration < 0.05){
        this.stopChannelPair(channelName);
        return;
      }
      const Bindex = this.getABIndex(channelName, index);
      let metaB = ch.audioBuffers[Bindex];
      if(!metaB || !metaB.buffer){
        this.ensureChannelBuffer(channelName, Bindex).catch(()=>{});
        metaB = metaA;
      }

      const now = this.audioContext.currentTime;
      const fade = 0.35;

      const srcA = this.audioContext.createBufferSource(); srcA.buffer = metaA.buffer; srcA.loop = true;
      const preA = this.audioContext.createGain(); preA.gain.value = metaA.pregain;
      const crossA = this.audioContext.createGain(); crossA.gain.value = 1;

      const srcB = this.audioContext.createBufferSource(); srcB.buffer = metaB.buffer; srcB.loop = true;
      const preB = this.audioContext.createGain(); preB.gain.value = metaB.pregain;
      const crossB = this.audioContext.createGain(); crossB.gain.value = 0;

      srcA.connect(preA).connect(crossA).connect(ch.pannerA);
      srcB.connect(preB).connect(crossB).connect(ch.pannerB);

      srcA.start(now); srcB.start(now);

      if(ch.pair){
        const { srcA:oldA, srcB:oldB, crossA:oldGA, crossB:oldGB } = ch.pair;
        try{
          oldGA.gain.cancelScheduledValues(now); oldGA.gain.setValueAtTime(oldGA.gain.value, now);
          oldGB.gain.cancelScheduledValues(now); oldGB.gain.setValueAtTime(oldGB.gain.value, now);
          oldGA.gain.linearRampToValueAtTime(0, now + fade);
          oldGB.gain.linearRampToValueAtTime(0, now + fade);
          oldA.stop(now + fade + 0.05);
          oldB.stop(now + fade + 0.05);
        }catch{}
      }

      ch.pair = { srcA, srcB, preA, preB, crossA, crossB, indexA:index, indexB:Bindex };
      ch.currentIndex = index;

      this.updatePanWidthFromAstral();
      this.updateABDepthForChannel(channelName);
      this.startABTimer(channelName);
    }

    stopChannelPair(channelName){
      const ch = this.channels[channelName];
      if(!ch || !ch.pair) return;
      const now = this.audioContext.currentTime;
      try{
        ch.pair.crossA.gain.linearRampToValueAtTime(0, now + 0.25);
        ch.pair.crossB.gain.linearRampToValueAtTime(0, now + 0.25);
        ch.pair.srcA.stop(now + 0.3);
        ch.pair.srcB.stop(now + 0.3);
      }catch{}
      ch.pair = null;
      if(ch.abTimer){ clearInterval(ch.abTimer); ch.abTimer = null; }
      ch.currentIndex = null;
    }

    updateABDepthForChannel(channelName){
      const ch = this.channels[channelName];
      if(!ch) return;
      const L = parseFloat(this.el('lucidSlider').value)/100;
      const depth = 0.5 * Math.pow(L, 2.0);
      ch.abDepth = depth;
    }

    startABTimer(channelName){
      const ch = this.channels[channelName];
      if(!ch || !ch.pair) return;
      if(ch.abTimer){ clearInterval(ch.abTimer); ch.abTimer = null; }

      const step = 0.5;
      ch.abTimer = setInterval(()=>{
        if(!this.isInitialized || !ch.pair) return;
        const now = this.audioContext.currentTime;

        ch.abPhase += 2*Math.PI*ch.abFreq*step;

        const base = ch.abDepth * 0.5;
        const amp  = ch.abDepth * 0.15;
        let x = base + amp * Math.sin(ch.abPhase);

        x = Math.max(0, Math.min(1, x));
        const gB = Math.sin(x * Math.PI/2);
        const gA = Math.cos(x * Math.PI/2);

        ch.pair.crossA.gain.setTargetAtTime(gA, now, 0.25);
        ch.pair.crossB.gain.setTargetAtTime(gB, now, 0.25);
      }, step*1000);
    }

    updatePanWidthFromAstral(){
      const L = parseFloat(this.el('astralSlider').value)/100;
      const widthMax = 0.75;
      const depth = widthMax * Math.pow(L, 1.6);

      this.orderedChannelNames.forEach(name=>{
        const ch = this.channels[name];
        if(!ch) return;
        ch.panDepthA.gain.setTargetAtTime(depth, this.audioContext.currentTime, 0.2);
        ch.panDepthB.gain.setTargetAtTime(depth, this.audioContext.currentTime, 0.2);
        if(depth < 0.001){
          ch.pannerA.pan.setTargetAtTime(0, this.audioContext.currentTime, 0.1);
          ch.pannerB.pan.setTargetAtTime(0, this.audioContext.currentTime, 0.1);
        }
      });
    }

    startLFOs(){
      if(!this.audioContext){ return; }

      const floorVal = 0.1;
      const lfoRange = 1.0 - floorVal;

      const createLFOEnvelope = (freq)=>{
        const osc = this.audioContext.createOscillator(); osc.frequency.value = freq; osc.type = 'sine';
        const modulationGain = this.audioContext.createGain(); modulationGain.gain.value = lfoRange/2;
        osc.connect(modulationGain);
        const baseOffset = this.audioContext.createConstantSource(); baseOffset.offset.value = (lfoRange/2) + floorVal;
        osc.start(); baseOffset.start();
        return { modulationGainNode:modulationGain, baseOffsetNode:baseOffset };
      };

      this.lucidLFOComponents.groupA = createLFOEnvelope(1/160);
      this.lucidLFOComponents.groupB = createLFOEnvelope(1/245);

      this.orderedChannelNames.forEach(name=>{
        const ch = this.channels[name];
        const group = (name === 'sky' || name === 'fire') ? this.lucidLFOComponents.groupA : this.lucidLFOComponents.groupB;
        if(ch && ch.lucidControls && ch.lucidControls.wetMixGain && group){
          group.modulationGainNode.connect(ch.lucidControls.wetMixGain);
          group.baseOffsetNode.connect(ch.lucidControls.wetMixGain);
        }
      });

      const astralFreqs = [1/160, 1/140, 1/180, 1/120];
      this.orderedChannelNames.forEach((name, i)=>{
        const lfo = this.audioContext.createOscillator();
        const lfoGain = this.audioContext.createGain();
        const baseFreqNode = this.audioContext.createConstantSource();

        lfo.frequency.value = astralFreqs[i % astralFreqs.length];
        lfo.type = 'sine';
        lfoGain.gain.value = 6000;
        baseFreqNode.offset.value = 7000;

        lfo.connect(lfoGain);
        if(this.astralFilters[name] && this.astralFilters[name].frequency){
          lfoGain.connect(this.astralFilters[name].frequency);
          baseFreqNode.connect(this.astralFilters[name].frequency);
        }
        lfo.start(); baseFreqNode.start();
        this.astralLFOs[name] = { lfo, lfoGain, baseFreqNode };
      });
    }

    updateKnobColor(elementId, percentage){
      const knobImage = this.el(elementId);
      if(!knobImage) return;
      const value = parseFloat(percentage)/100;
      const hueMinDeg = 0, hueMaxDeg = 180;
      const targetHue = hueMinDeg + (hueMaxDeg - hueMinDeg)*value;
      const brightness = 0.8 + 0.4*value;
      knobImage.style.filter = `hue-rotate(${targetHue}deg) saturate(1.5) brightness(${brightness})`;
    }

    refreshInitialKnobColours(){
      ['astral','lucid','master','sky','fire','earth','sea'].forEach(name=>{
        const slider = this.el(`${name}Slider`);
        if(slider){ this.updateKnobColor(`${name}Knob`, parseFloat(slider.value)); }
      });
      this.updateTintOverlay();
    }

    updateTintOverlay(){
      const vSky   = parseFloat(this.el('skySlider').value)/100;
      const vFire  = parseFloat(this.el('fireSlider').value)/100;
      const vEarth = parseFloat(this.el('earthSlider').value)/100;
      const vSea   = parseFloat(this.el('seaSlider').value)/100;

      const col = (r,g,b)=>({r,g,b});
      const skyPink = col(255,105,180);
      const fireOrng= col(255,140,0);
      const earthGrn= col(46,204,113);
      const seaBlue = col(64,156,255);

      const wSum = vSky + vFire + vEarth + vSea + 1e-6;
      const chanCol = {
        r:(vSky*skyPink.r + vFire*fireOrng.r + vEarth*earthGrn.r + vSea*seaBlue.r) / wSum,
        g:(vSky*skyPink.g + vFire*fireOrng.g + vEarth*earthGrn.g + vSea*seaBlue.g) / wSum,
        b:(vSky*skyPink.b + vFire*fireOrng.b + vEarth*earthGrn.b + vSea*seaBlue.b) / wSum
      };

      const bias = this.eqTintMap[this.eqMode] || this.eqTintMap.white;
      const t = bias.weight;
      let final = {
        r: chanCol.r*(1-t) + bias.r*t,
        g: chanCol.g*(1-t) + bias.g*t,
        b: chanCol.b*(1-t) + bias.b*t
      };

      if(this.layerTintBias){
        const weight = Math.min(0.45, Math.max(0, this.layerTintBiasWeight));
        final = {
          r: final.r*(1-weight) + this.layerTintBias.r*weight,
          g: final.g*(1-weight) + this.layerTintBias.g*weight,
          b: final.b*(1-weight) + this.layerTintBias.b*weight
        };
      }

      const alpha = Math.min(0.92, 0.30 + 0.50 * ((wSum - 1e-6) / 4));
      const overlay = this.el('tintOverlay');
      overlay.style.backgroundColor = `rgba(${final.r.toFixed(0)}, ${final.g.toFixed(0)}, ${final.b.toFixed(0)}, ${alpha.toFixed(3)})`;
    }

    fadeIn(gainParam, t, d=0.08){
      gainParam.cancelScheduledValues(t);
      gainParam.setValueAtTime(0, t);
      gainParam.linearRampToValueAtTime(1, t + d);
    }
    fadeOut(gainParam, t, d=0.08){
      gainParam.cancelScheduledValues(t);
      gainParam.setValueAtTime(gainParam.value, t);
      gainParam.linearRampToValueAtTime(0, t + d);
    }

    initializeEventListeners(){
      this.boundInitializeListener = async ()=>{
        this.removeStartListeners();
        if(!this.suppressUserStartCallback && typeof this.options.onUserStart === 'function'){
          try{ this.options.onUserStart(this); }
          catch(err){ console.error('SLUMBR start handler error:', err); }
        }
        if(!this.isInitialized){ await this.initialize(); }
        else if(this.audioContext && this.audioContext.state === 'suspended'){ await this.audioContext.resume(); }
      };
      this.addStartListeners();

      const masterSlider = this.el('masterSlider');
      const masterReadout = this.el('masterReadout');
      masterSlider.addEventListener('input', (e)=>{
        if(!this.isInitialized || !this.masterGain) return;
        const t = this.audioContext.currentTime;
        const g = this.gainFromSlider(parseFloat(e.target.value));
        this.masterGain.gain.setTargetAtTime(g, t, 0.015);
        masterReadout.textContent = e.target.value;
        this.updateKnobColor('masterKnob', parseFloat(e.target.value));
        this.updateTintOverlay();
      });

      const astralSlider = this.el('astralSlider');
      const astralReadout = this.el('astralReadout');
      astralSlider.addEventListener('input', (e)=>{
        if(!this.isInitialized) return;
        const value = parseFloat(e.target.value)/100;
        this.orderedChannelNames.forEach(n=>{
          const ch = this.channels[n];
          if(ch && ch.astralWetGain){
            ch.astralWetGain.gain.setTargetAtTime(value, this.audioContext.currentTime, 0.015);
          }
        });
        this.updatePanWidthFromAstral();
        astralReadout.textContent = e.target.value;
        this.updateKnobColor('astralKnob', parseFloat(e.target.value));
      });

      const lucidSlider = this.el('lucidSlider');
      const lucidReadout = this.el('lucidReadout');
      lucidSlider.addEventListener('input', (e)=>{
        if(!this.isInitialized) return;
        const L = parseFloat(e.target.value)/100;
        this.orderedChannelNames.forEach(n=>{
          const ch = this.channels[n];
          if(ch && ch.lucidControls){
            ch.lucidControls.dryMixGain.gain.setTargetAtTime(1 - L, this.audioContext.currentTime, 0.015);
            ch.lucidControls.wetMixGain.gain.setTargetAtTime(L, this.audioContext.currentTime, 0.015);
          }
          this.updateABDepthForChannel(n);
        });
        lucidReadout.textContent = e.target.value;
        this.updateKnobColor('lucidKnob', parseFloat(e.target.value));
      });

      this.orderedChannelNames.forEach(channelName=>{
        const slider  = this.el(`${channelName}Slider`);
        const readout = this.el(`${channelName}Readout`);
        const spinner = this.el(`${channelName}Spinner`);

        slider.addEventListener('input', (e)=>{
          if(!this.isInitialized) return;
          const v = this.gainFromSlider(parseFloat(e.target.value));
          if(this.channels[channelName] && this.channels[channelName].gain){
            this.channels[channelName].gain.gain.setTargetAtTime(v, this.audioContext.currentTime, 0.015);
          }
          readout.textContent = e.target.value;
          this.updateKnobColor(`${channelName}Knob`, parseFloat(e.target.value));
          this.updateTintOverlay();
        });

        spinner.addEventListener('change', (e)=>{
          if(!this.isInitialized) return;
          const index = parseInt(e.target.value, 10);
          this.switchChannelSound(channelName, index);
        });
      });

      const eqMap = { eqWhite:'white', eqPink:'pink', eqGreen:'green', eqBrown:'brown', eqBlack:'black' };
      Object.keys(eqMap).forEach(id=>{
        const mode = eqMap[id];
        const el = this.el(id);
        el.addEventListener('click', ()=> this.setEQMode(mode));
      });

      const saveButton = this.el('saveButton');
      if(saveButton){
        saveButton.addEventListener('click', (event)=>{
          event.preventDefault();
          if(this.options.onRequestSaveAll){
            this.options.onRequestSaveAll(this);
          }else{
            this.saveState();
          }
        });
      }

      const loadButton = this.el('loadButton');
      if(loadButton){
        loadButton.addEventListener('click', (event)=>{
          event.preventDefault();
          if(this.options.onRequestLoadAll){
            this.options.onRequestLoadAll(this);
          }else{
            this.loadState();
          }
        });
      }

      const randomizeButton = this.el('randomizeButton');
      if(randomizeButton){
        randomizeButton.addEventListener('click', (event)=>{
          event.preventDefault();
          if(this.options.onRequestRandomizeAll){
            this.options.onRequestRandomizeAll(this);
            return;
          }
          if(!this.isInitialized) return;
          const state = this.generateRandomState();
          this.applyState(state);
        });
      }
    }

    generateRandomState(){
      const eqModes = Object.keys(this.eqTintMap);
      const pickEq = eqModes[this.randomInt(0, Math.max(0, eqModes.length - 1))] || 'white';
      const randomSliderValue = (min, max)=> String(this.randomInt(min, max));
      const state = {
        master: '40',
        astral: randomSliderValue(30, 90),
        lucid: randomSliderValue(20, 85),
        eq: pickEq,
        channels: {}
      };
      this.orderedChannelNames.forEach(name=>{
        const spinner = this.el(`${name}Spinner`);
        const availableOptions = spinner ? Array.from(spinner.options).filter(opt=> !opt.disabled) : [];
        const optionValues = availableOptions.length ? availableOptions.map(opt=> parseInt(opt.value, 10)) : this.channelData[name]?.files?.map((_, idx)=> idx) || [0];
        const choiceIndex = this.randomInt(0, Math.max(0, optionValues.length - 1));
        const selectionIndex = optionValues[choiceIndex] ?? 0;
        state.channels[name] = {
          volume: randomSliderValue(35, 85),
          selection: String(selectionIndex)
        };
      });
      return state;
    }

    applyState(state){
      if(!this.isInitialized || !state) return;
      const applySlider = (id, value)=>{
        const el = this.el(id);
        if(!el || value === undefined || value === null) return;
        const v = Math.max(0, Math.min(100, parseInt(value, 10)));
        el.value = String(Number.isFinite(v) ? v : 0);
        el.dispatchEvent(new Event('input', { bubbles:true }));
      };
      const applySpinner = (channelName, value)=>{
        const el = this.el(`${channelName}Spinner`);
        if(!el || value === undefined || value === null) return;
        const desired = String(value);
        const options = Array.from(el.options || []);
        const valid = options.find(opt=> opt.value === desired && !opt.disabled);
        if(valid){
          el.value = desired;
          el.dispatchEvent(new Event('change', { bubbles:true }));
          return;
        }
        const numeric = parseInt(desired, 10);
        if(Number.isFinite(numeric)){
          this.pendingChannelSelections[channelName] = numeric;
          this.ensureChannelBuffer(channelName, numeric).catch(()=>{});
        }
        const fallback = options.find(opt=> !opt.disabled) || options[0];
        if(fallback){
          el.value = fallback.value;
          el.dispatchEvent(new Event('change', { bubbles:true }));
        }
      };

      applySlider('masterSlider', state.master ?? '40');
      applySlider('astralSlider', state.astral ?? this.el('astralSlider').value);
      applySlider('lucidSlider', state.lucid ?? this.el('lucidSlider').value);

      if(state.channels){
        this.orderedChannelNames.forEach(name=>{
          const channelState = state.channels[name];
          if(!channelState) return;
          applySlider(`${name}Slider`, channelState.volume);
          applySpinner(name, channelState.selection);
        });
      }

      const eqMode = typeof state.eq === 'string' ? state.eq : 'white';
      this.setEQMode(this.eqTintMap[eqMode] ? eqMode : 'white');
      this.updatePanWidthFromAstral();
    }

    saveState(){
      if(!this.isInitialized){ return; }
      const state = {
        master: this.el('masterSlider').value,
        astral: this.el('astralSlider').value,
        lucid: this.el('lucidSlider').value,
        eq: this.eqMode || 'white',
        channels: {}
      };
      this.orderedChannelNames.forEach(n=>{
        state.channels[n] = {
          volume: this.el(`${n}Slider`).value,
          selection: this.el(`${n}Spinner`).value
        };
      });
      localStorage.setItem(this.storageKey(), JSON.stringify(state));
    }

    loadState(){
      if(!this.isInitialized){ return; }
      let state = null;
      const saved = this.loadStoredState();
      if(saved){
        try{
          const parsed = JSON.parse(saved);
          if(parsed && typeof parsed === 'object'){ state = parsed; }
        }catch(err){
          console.warn('Failed to parse saved SLUMBR state:', err);
        }
      }
      if(!state){ state = this.generateRandomState(); }
      this.applyState(state);
    }

    storageKey(){
      return `slumbr_state_v7_layer_${this.index}`;
    }

    loadStoredState(){
      const primary = localStorage.getItem(this.storageKey());
      if(primary) return primary;
      if(this.index === 0){
        return localStorage.getItem('slumbr_state_v6') || localStorage.getItem('slumbr_state_v5');
      }
      return null;
    }

    async requestWakeLock(){
      if('wakeLock' in navigator){
        try{
          this.wakeLock = await navigator.wakeLock.request('screen');
          this.wakeLock.addEventListener('release', ()=>{});
          document.addEventListener('visibilitychange', async ()=>{
            if(document.visibilityState === 'visible'){
              try{ this.wakeLock = await navigator.wakeLock.request('screen'); }catch{}
            }
          });
        }catch{}
      }
    }

    setVisible(isVisible){
      const active = !!isVisible;
      this.root.classList.toggle('is-active', active);
      this.root.style.display = active ? 'block' : 'none';
      if(active){ this.updateTintOverlay(); }
    }
  }

  class SlumbrLayersManager {
    constructor(){
      this.layerStack = document.getElementById('layerStack');
      this.template = document.getElementById('slumbrLayerTemplate');
      this.layerButtons = Array.from(document.querySelectorAll('.layer-dot'));
      this.layers = [];
      this.activeIndex = 0;
      this.onLayerChange = null;

      this.layerConfigs = [
        { label:'Aurora', baseTint:{ r:120, g:180, b:255 }, baseTintWeight:0.30, theme:'layer-theme-blue', startText:'Start Aurora' },
        { label:'Verdant', baseTint:{ r:110, g:240, b:170 }, baseTintWeight:0.28, theme:'layer-theme-green', startText:'Start Verdant' },
        { label:'Crimson', baseTint:{ r:255, g:150, b:160 }, baseTintWeight:0.32, theme:'layer-theme-red', startText:'Start Crimson' }
      ];

      this.layerButtons.forEach((button, idx)=>{
        button.addEventListener('click', ()=> this.activateLayer(idx));
      });

      this.layerConfigs.forEach((_, idx)=> this.ensureLayer(idx));
      this.activateLayer(0);
    }

    ensureLayer(index){
      if(this.layers[index]) return this.layers[index];
      const config = this.layerConfigs[index] || {};
      const fragment = this.template.content.firstElementChild.cloneNode(true);
      if(config.theme){ fragment.classList.add(config.theme); }
      fragment.style.display = 'none';
      this.layerStack.appendChild(fragment);

      const layerOptions = {
        ...config,
        onUserStart: (layerInstance)=> this.handleLayerUserStart(layerInstance),
        onRequestSaveAll: ()=> this.saveAll(true),
        onRequestLoadAll: ()=> this.loadAll(),
        onRequestRandomizeAll: ()=> this.randomizeAll()
      };

      const layer = new SlumbrLayer(fragment, index, layerOptions);
      this.layers[index] = layer;
      return layer;
    }

    activateLayer(index){
      const layer = this.ensureLayer(index);
      if(!layer) return;
      this.layers.forEach((l, idx)=>{ if(l){ l.setVisible(idx === index); } });
      this.layerButtons.forEach((btn, idx)=> btn.classList.toggle('active', idx === index));
      this.activeIndex = index;
      if(typeof this.onLayerChange === 'function'){ this.onLayerChange(index); }
    }

    getActiveLayerElement(){
      const activeLayer = this.layers[this.activeIndex];
      return activeLayer ? activeLayer.root : null;
    }

    saveAll(forceInitialize = false){
      this.layers.forEach(layer=>{
        if(!layer) return;
        const performSave = ()=>{ try{ layer.saveState(); }catch(err){ console.error('Failed to save layer state', err); } };
        if(layer.isInitialized){
          performSave();
        }else if(forceInitialize){
          layer.externalInitialize().then(performSave).catch(err=> console.error('Failed to start layer for save', err));
        }
      });
    }

    loadAll(){
      this.layers.forEach(layer=>{
        if(!layer) return;
        const performLoad = ()=>{ try{ layer.loadState(); }catch(err){ console.error('Failed to load layer state', err); } };
        if(layer.isInitialized){
          performLoad();
        }else{
          layer.externalInitialize().then(performLoad).catch(err=> console.error('Failed to start layer for load', err));
        }
      });
    }

    randomizeAll(){
      this.layers.forEach(layer=>{
        if(!layer) return;
        const applyRandom = ()=>{
          try{
            const state = layer.generateRandomState();
            layer.applyState(state);
          }catch(err){
            console.error('Failed to randomize layer state', err);
          }
        };
        if(layer.isInitialized){
          applyRandom();
        }else{
          layer.externalInitialize().then(applyRandom).catch(err=> console.error('Failed to start layer for randomize', err));
        }
      });
    }

    handleLayerUserStart(originLayer){
      this.layers.forEach(layer=>{
        if(layer && layer !== originLayer && !layer.isInitialized){
          layer.externalInitialize().catch(err=> console.error('Failed to auto-start layer', err));
        }
      });
    }
  }

  const slumbrLayers = new SlumbrLayersManager();

  class SlumbrGuidedTour {
    constructor(manager){
      this.manager = manager;
      this.overlay = document.querySelector('[data-id="tourOverlay"]');
      if(!this.overlay) return;
      this.card = this.overlay.querySelector('[data-id="tourCard"]');
      this.pointer = this.overlay.querySelector('[data-id="tourPointer"]');
      this.titleEl = this.overlay.querySelector('[data-id="tourTitle"]');
      this.copyEl = this.overlay.querySelector('[data-id="tourCopy"]');
      this.prevBtn = this.overlay.querySelector('[data-id="tourPrev"]');
      this.nextBtn = this.overlay.querySelector('[data-id="tourNext"]');
      this.dismissBtn = this.overlay.querySelector('[data-id="tourDismiss"]');
      this.activeHighlight = null;
      this.storageKey = 'slumbr_tour_seen_v2';
      this.steps = [
        {
          title:'Master output',
          copy:'Turn SLUMBR on with this main dial and set the overall volume and force for your mix.',
          getTarget:()=> this.activeLayerQuery('.control-knob.master')
        },
        {
          title:'Element mixers',
          copy:'Each element has its own volume knob and a spinner underneath – tap it to choose from different textures for that element.',
          getTarget:()=> this.activeLayerQuery('.channel.sky')
        },
        {
          title:'Astral & Lucid modes',
          copy:'Astral widens the panorama while Lucid adds motion and depth. Blend them together for evolving soundscapes.',
          getTarget:()=> this.activeLayerQuery('.control-knob.astral')
        },
        {
          title:'Triplets mode',
          copy:'Use the triple-dot selector to engage up to three simultaneous scenes for richer, triplet-style layering.',
          getTarget:()=> document.querySelector('.layer-switcher')
        },
        {
          title:'Save, Load & Randomise',
          copy:'Store your favourite blends, recall past sessions, or let SLUMBR surprise you at any moment.',
          getTarget:()=> this.activeLayerQuery('.save-load-buttons')
        }
      ];
      this.index = 0;
      this.boundResize = ()=> this.positionCurrentStep();
      this.bindEvents();
      if(this.manager){ this.manager.onLayerChange = ()=> this.positionCurrentStep(); }
      setTimeout(()=> this.startIfNeeded(), 600);
    }

    activeLayerQuery(selector){
      const layer = this.manager?.getActiveLayerElement?.();
      if(layer){ return layer.querySelector(selector); }
      return document.querySelector(selector);
    }

    bindEvents(){
      if(this.prevBtn){ this.prevBtn.addEventListener('click', ()=> this.prev()); }
      if(this.nextBtn){ this.nextBtn.addEventListener('click', ()=> this.next()); }
      if(this.dismissBtn){ this.dismissBtn.addEventListener('click', ()=> this.finish()); }
      window.addEventListener('resize', this.boundResize);
      document.addEventListener('visibilitychange', ()=>{ if(!document.hidden){ this.positionCurrentStep(); } });
    }

    startIfNeeded(){
      if(!this.overlay) return;
      try{
        if(localStorage.getItem(this.storageKey)){ return; }
      }catch{}
      this.showStep(0);
    }

    showStep(index){
      if(!this.overlay) return;
      this.index = Math.min(Math.max(index, 0), this.steps.length - 1);
      const step = this.steps[this.index];
      const target = step?.getTarget?.();
      this.overlay.hidden = false;
      if(this.titleEl){ this.titleEl.textContent = step?.title || ''; }
      if(this.copyEl){ this.copyEl.textContent = step?.copy || ''; }
      this.toggleButtonState();
      this.highlightTarget(target);
      this.positionCard(target);
    }

    highlightTarget(target){
      if(this.activeHighlight){ this.activeHighlight.classList.remove('tour-highlight'); }
      if(target){
        target.classList.add('tour-highlight');
        this.activeHighlight = target;
      }else{
        this.activeHighlight = null;
      }
    }

    positionCard(target){
      if(!this.card) return;
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const padding = 24;
      const cardRect = this.card.getBoundingClientRect();
      const cardWidth = cardRect.width || 300;
      const cardHeight = cardRect.height || 180;
      let top = padding;
      let left = (viewportWidth - cardWidth) / 2;
      let pointerClass = '';

      if(target){
        const rect = target.getBoundingClientRect();
        left = rect.left + rect.width/2 - cardWidth/2;
        left = Math.max(padding, Math.min(viewportWidth - cardWidth - padding, left));
        top = rect.bottom + 16;
        pointerClass = '';
        if(top + cardHeight > viewportHeight - padding){
          top = rect.top - cardHeight - 16;
          pointerClass = 'bottom';
        }
        if(top < padding){ top = padding; }
      }

      this.card.style.left = `${left}px`;
      this.card.style.top = `${top}px`;
      if(this.pointer){
        this.pointer.classList.toggle('bottom', pointerClass === 'bottom');
        const rect = target ? target.getBoundingClientRect() : null;
        if(rect){
          const cardLeft = left;
          const pointerOffset = rect.left + rect.width/2 - cardLeft;
          this.pointer.style.left = `${Math.max(24, Math.min(cardWidth - 24, pointerOffset)) - 14}px`;
        }else{
          this.pointer.style.left = 'calc(50% - 14px)';
        }
      }
    }

    positionCurrentStep(){
      const step = this.steps[this.index];
      const target = step?.getTarget?.();
      this.positionCard(target);
    }

    toggleButtonState(){
      if(this.prevBtn){ this.prevBtn.disabled = this.index === 0; }
      if(this.nextBtn){ this.nextBtn.textContent = this.index === this.steps.length - 1 ? 'Finish' : 'Next'; }
    }

    prev(){
      if(this.index <= 0){ return; }
      this.showStep(this.index - 1);
    }

    next(){
      if(this.index >= this.steps.length - 1){ this.finish(); return; }
      this.showStep(this.index + 1);
    }

    finish(){
      if(this.activeHighlight){ this.activeHighlight.classList.remove('tour-highlight'); this.activeHighlight = null; }
      if(this.overlay){ this.overlay.hidden = true; }
      try{ localStorage.setItem(this.storageKey, '1'); }catch{}
    }
  }

  const slumbrTour = new SlumbrGuidedTour(slumbrLayers);

  window.addEventListener('beforeunload', ()=> slumbrLayers.saveAll(false));

  if('serviceWorker' in navigator){
    window.addEventListener('load', ()=>{ navigator.serviceWorker.register('./sw.js').catch(()=>{}); });
  }
  </script>

  <div style="text-align:center; margin-top:20px;">
    <a href="https://mikewhyle.com/ai/" target="_blank" rel="noopener">
      <img src="ad-mikewhyle-ai-consultant.png" alt="AI Consultant" style="max-width:100%; height:auto;">
    </a>
  </div>
</body>
</html>
