<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>SLUMBR</title>

  <!-- PWA -->
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#101020">
  <link rel="icon" type="image/png" href="astral_knob.png"/>

  <style>
    *{ margin:0; padding:0; box-sizing:border-box; }
    body{ font-family:Arial, sans-serif; background:#1a1a2e; overflow:hidden; user-select:none; color:white; }

    .app-container{
      width:540px; height:835px; position:relative; margin:20px auto;
      background-image:url('background.png'); background-size:cover; background-position:center; background-repeat:no-repeat;
    }

    /* global tint overlay: recolours the whole app (incl. background.png) */
    #tintOverlay{
      position:absolute; inset:0; pointer-events:none;
      background:rgba(0,0,0,0);
      transition:background-color 0.6s ease;
      mix-blend-mode: color; /* key: hue/colour blend rather than simple alpha */
    }

    .channel{
      position:absolute; display:flex; flex-direction:column; align-items:center;
      width:95px; height:240px; padding:4px;
    }

    .knob-container{ position:relative; width:75px; height:75px; }
    .knob-slider{ position:absolute; width:100%; height:100%; opacity:0; cursor:pointer; z-index:2; margin:0; }
    .knob-image{
      position:absolute; width:100%; height:100%; background-size:contain; background-repeat:no-repeat; background-position:center;
      pointer-events:none; filter:hue-rotate(180deg) saturate(1.5); transition:filter 0.1s ease;
    }
    .knob-readout{ width:75px; height:24px; text-align:center; font-size:12px; color:white; line-height:24px; margin-top:2px; }

    .channel-spinner{
      width:90px; height:36px; background:transparent; border:1.5px solid rgba(58,137,255,0.4); border-radius:8px;
      color:white; font-size:18px; text-align:center; text-align-last:center; cursor:pointer; padding:0 4px;
      -webkit-appearance:none; -moz-appearance:none; appearance:none;
    }
    .channel-spinner:focus{ outline:none; border-color:rgba(58,137,255,0.8); }
    select.channel-spinner option{ background:#1f1f3d; color:white; font-size:16px; }
    select.channel-spinner option:hover{ background:#3c3c5d; }

    .control-knob{ position:absolute; display:flex; flex-direction:column; align-items:center; }
    .control-knob.small .knob-container{ width:50px; height:50px; }
    .control-knob.small .knob-readout{ width:50px; font-size:10px; height:18px; line-height:18px; margin-top:2px; }
    .control-knob.large .knob-container{ width:150px; height:150px; }
    .control-knob.large .knob-readout{ width:150px; font-size:14px; height:24px; line-height:24px; margin-top:2px; }

    .save-load-buttons{ position:absolute; bottom:8px; left:50%; transform:translateX(-50%); display:flex; gap:20px; }
    .save-load-button{ width:120px; height:80px; background:transparent; border:none; color:white; font-size:18px; cursor:pointer; padding:10px; }
    .save-load-button:hover{ background:rgba(255,255,255,0.1); border-radius:8px; }

    /* EQ buttons: smaller, subtly colour-coded */
    .eq-buttons{
      position:absolute; bottom:100px; left:50%; transform:translateX(-50%);
      display:flex; gap:6px; align-items:center; justify-content:center;
    }
    .eq-button{
      width:16px; height:16px; border-radius:50%;
      border:1px solid rgba(255,255,255,0.5); background:transparent; cursor:pointer;
      box-shadow: 0 0 0 0 rgba(0,0,0,0) inset;
      transition: box-shadow 0.2s ease, transform 0.05s ease;
    }
    .eq-button:active{ transform: scale(0.96); }
    .eq-button.active{ box-shadow:0 0 0 2px rgba(255,255,255,0.45) inset; }

    /* colour hints */
    .eq-white{ background: rgba(255,255,255,0.28); }
    .eq-pink { background: rgba(255,105,180,0.32); }
    .eq-green{ background: rgba(46,204,113,0.32); }
    .eq-brown{ background: rgba(165,94,41,0.32); }
    .eq-black{ background: rgba(20,24,30,0.55); }

    /* Layout anchors preserved */
    .channel.sky{ left:calc(28% - 47.5px); top:calc(58% - 120px); }
    .channel.fire{ left:calc(74% - 47.5px); top:calc(58% - 120px); }
    .channel.earth{ left:calc(27% - 47.5px); top:calc(78% - 120px); }
    .channel.sea{ left:calc(73% - 47.5px); top:calc(78% - 120px); }
    .control-knob.astral{ left:calc(38% - 25px); top:calc(28% - 25px); }
    .control-knob.lucid{ left:calc(62% - 25px); top:calc(28% - 25px); }
    .control-knob.master{ left:calc(50% - 75px); top:calc(64% - 75px); }

    .channel-content{ display:flex; flex-direction:column; align-items:center; justify-content:center; gap:4px; width:100%; }
    .channel.earth .channel-content > .channel-spinner,
    .channel.sea  .channel-content > .channel-spinner{ order:1; }
    .channel.earth .channel-content > .knob-container,
    .channel.sea  .channel-content > .knob-container{ order:2; }
    .channel.earth .channel-content > .knob-readout,
    .channel.sea  .channel-content > .knob-readout{ order:3; }

    .channel.sky .channel-content > .knob-container,
    .channel.fire .channel-content > .knob-container{ order:1; }
    .channel.sky .channel-content > .knob-readout,
    .channel.fire .channel-content > .knob-readout{ order:2; }
    .channel.sky .channel-content > .channel-spinner,
    .channel.fire .channel-content > .channel-spinner{ order:3; }

    .loading-indicator{
      position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      color:white; font-size:18px; text-align:center; padding:20px; background-color:rgba(0,0,0,0.5); border-radius:8px;
    }

    @media (max-width:560px){
      .app-container{ width:100%; height:auto; padding-bottom:154.63%; margin:5px auto; border:none; }
    }
  </style>
</head>
<body>
  <div class="app-container">
    <div id="tintOverlay" aria-hidden="true"></div>

    <div class="loading-indicator" id="loadingIndicator" aria-live="polite">Start SLUMBR</div>

    <div class="control-knob astral small">
      <div class="knob-container small">
        <input type="range" min="0" max="100" value="82" class="knob-slider small" id="astralSlider" aria-label="Astral wet amount">
        <div class="knob-image small" id="astralKnob" style="background-image:url('astral_knob.png');" role="img" aria-label="Astral control"></div>
      </div>
      <div class="knob-readout" id="astralReadout" aria-live="polite">82</div>
    </div>

    <div class="control-knob lucid small">
      <div class="knob-container small">
        <input type="range" min="0" max="100" value="92" class="knob-slider small" id="lucidSlider" aria-label="Lucid modulation depth">
        <div class="knob-image small" id="lucidKnob" style="background-image:url('lucid_knob.png');" role="img" aria-label="Lucid control"></div>
      </div>
      <div class="knob-readout" id="lucidReadout" aria-live="polite">92</div>
    </div>

    <div class="channel sky">
      <div class="channel-content">
        <div class="knob-container">
          <input type="range" min="0" max="100" value="53" class="knob-slider" id="skySlider" aria-label="Sky channel volume">
          <div class="knob-image" id="skyKnob" style="background-image:url('sky_knob.png');" role="img" aria-label="Sky channel knob"></div>
        </div>
        <div class="knob-readout" id="skyReadout" aria-live="polite">53</div>
        <select class="channel-spinner" id="skySpinner" aria-label="Sky sound">
          <option value="0">Tempest</option><option value="1">Breeze</option><option value="2">Balmy</option>
          <option value="3">Temple</option><option value="4">Rain</option><option value="5">Mountains</option><option value="6">Spring</option>
        </select>
      </div>
    </div>

    <div class="channel fire">
      <div class="channel-content">
        <div class="knob-container">
          <input type="range" min="0" max="100" value="59" class="knob-slider" id="fireSlider" aria-label="Fire channel volume">
          <div class="knob-image" id="fireKnob" style="background-image:url('fire_knob.png');" role="img" aria-label="Fire channel knob"></div>
        </div>
        <div class="knob-readout" id="fireReadout" aria-live="polite">59</div>
        <select class="channel-spinner" id="fireSpinner" aria-label="Fire sound">
          <option value="0">Hearth</option><option value="1">Forge</option><option value="2">Ember</option>
          <option value="3">Crackle</option><option value="4">Campfire</option><option value="5">Summer</option><option value="6">Desert</option>
        </select>
      </div>
    </div>

    <div class="control-knob master large">
      <div class="knob-container large">
        <input type="range" min="0" max="100" value="77" class="knob-slider large" id="masterSlider" aria-label="Master volume">
        <div class="knob-image large" id="masterKnob" style="background-image:url('master_knob.png');" role="img" aria-label="Master knob"></div>
      </div>
      <div class="knob-readout" id="masterReadout" aria-live="polite">77</div>
    </div>

    <div class="channel earth">
      <div class="channel-content">
        <select class="channel-spinner" id="earthSpinner" aria-label="Earth sound">
          <option value="0">Kiln</option><option value="1">Magma</option><option value="2">Crevasse</option>
          <option value="3">Core</option><option value="4">Forest</option><option value="5">Autumn</option><option value="6">Cave</option>
        </select>
        <div class="knob-container">
          <input type="range" min="0" max="100" value="50" class="knob-slider" id="earthSlider" aria-label="Earth channel volume">
          <div class="knob-image" id="earthKnob" style="background-image:url('earth_knob.png');" role="img" aria-label="Earth channel knob"></div>
        </div>
        <div class="knob-readout" id="earthReadout" aria-live="polite">50</div>
      </div>
    </div>

    <div class="channel sea">
      <div class="channel-content">
        <select class="channel-spinner" id="seaSpinner" aria-label="Sea sound">
          <option value="0">Stormy</option><option value="1">Brook</option><option value="2">Winter</option>
          <option value="3">Lake</option><option value="4">Deep</option><option value="5">Glade</option><option value="6">Creek</option>
        </select>
        <div class="knob-container">
          <input type="range" min="0" max="100" value="55" class="knob-slider" id="seaSlider" aria-label="Sea channel volume">
          <div class="knob-image" id="seaKnob" style="background-image:url('sea_knob.png');" role="img" aria-label="Sea channel knob"></div>
        </div>
        <div class="knob-readout" id="seaReadout" aria-live="polite">55</div>
      </div>
    </div>

    <!-- tiny EQ preset buttons -->
    <div class="eq-buttons" aria-label="EQ presets">
      <button class="eq-button eq-white active" id="eqWhite" title="White EQ" aria-label="White EQ"></button>
      <button class="eq-button eq-pink"  id="eqPink"  title="Pink EQ"  aria-label="Pink EQ"></button>
      <button class="eq-button eq-green" id="eqGreen" title="Green EQ" aria-label="Green EQ"></button>
      <button class="eq-button eq-brown" id="eqBrown" title="Brown EQ" aria-label="Brown EQ"></button>
      <button class="eq-button eq-black" id="eqBlack" title="Black EQ" aria-label="Black EQ"></button>
    </div>

    <div class="save-load-buttons">
      <button class="save-load-button" id="saveButton" aria-label="Save preset"></button>
      <button class="save-load-button" id="loadButton" aria-label="Load preset"></button>
    </div>
  </div>

  <script>
  class SlumbrApp {
    constructor(){
      this.audioContext = null;
      this.isInitialized = false;

      this.channels = {};
      this.masterGain = null;
      this.eq = null;
      this.limiter = null;

      this.lucidLFOComponents = {};
      this.astralLFOs = {};
      this.astralFilters = {};

      this.wakeLock = null;

      this.eqMode = 'white';
      this.eqTintMap = {
        white:{ r:255, g:255, b:255, weight:0.10 },
        pink: { r:255, g:120, b:200, weight:0.28 },
        green:{ r:46,  g:204, b:113, weight:0.28 },
        brown:{ r:165, g:94,  b:41,  weight:0.28 },
        black:{ r:24,  g:28,  b:36,  weight:0.30 }
      };

      this.INITIAL_SETTINGS = {
        master: 0.77, sky: 0.53, fire: 0.59, earth: 0.50, sea: 0.55, astral: 0.82, lucid: 0.92
      };

      this.channelData = {
        sky:   { files:['sky1.ogg','sky2.ogg','sky3.ogg','sky4.ogg','sky5.ogg','sky6.ogg','sky7.ogg'], labels:['Tempest','Breeze','Balmy','Temple','Rain','Mountains','Spring'], initialVolume:this.INITIAL_SETTINGS.sky,   pan:+0.40 },
        fire:  { files:['fire1.ogg','fire2.ogg','fire3.ogg','fire4.ogg','fire5.ogg','fire6.ogg','fire7.ogg'], labels:['Hearth','Forge','Ember','Crackle','Campfire','Summer','Desert'], initialVolume:this.INITIAL_SETTINGS.fire,  pan:-0.50 },
        earth: { files:['earth1.ogg','earth2.ogg','earth3.ogg','earth4.ogg','earth5.ogg','earth6.ogg','earth7.ogg'], labels:['Kiln','Magma','Crevasse','Core','Forest','Autumn','Cave'], initialVolume:this.INITIAL_SETTINGS.earth, pan:-0.30 },
        sea:   { files:['sea1.ogg','sea2.ogg','sea3.ogg','sea4.ogg','sea5.ogg','sea6.ogg','sea7.ogg'], labels:['Stormy','Brook','Winter','Lake','Deep','Glade','Creek'], initialVolume:this.INITIAL_SETTINGS.sea,   pan:+0.60 }
      };
      this.orderedChannelNames = ['sky','fire','earth','sea'];

      this.initializeEventListeners();
    }

    gainFromSlider(v){ return Math.pow(v/100, 2.2); }

    async initialize(){
      if(this.isInitialized) return;
      if(this.audioContext && this.audioContext.state === 'running') return;

      const loadingIndicator = document.getElementById('loadingIndicator');
      try{
        if(!this.audioContext){
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        if(this.audioContext.state === 'suspended'){ await this.audioContext.resume(); }
        if(this.audioContext.state !== 'running'){
          loadingIndicator.textContent = 'AudioContext not running. Click again.';
          const clickListener = async ()=>{
            if(!this.isInitialized && this.audioContext && this.audioContext.state !== 'running'){ await this.initialize(); }
          };
          if(this.boundInitializeListener){ document.removeEventListener('click', this.boundInitializeListener); }
          this.boundInitializeListener = clickListener;
          document.addEventListener('click', this.boundInitializeListener, { once:true });
          return;
        }

        this.setupAudioGraph();
        this.startLFOs();
        await this.loadAllSounds();

        this.isInitialized = true;
        loadingIndicator.style.display = 'none';
        this.loadState();

        this.requestWakeLock();
        this.updateTintOverlay();
      }catch(err){
        console.error('Failed to initialize SLUMBR:', err);
        loadingIndicator.textContent = `Error: ${err.message}. Try refreshing.`;
        loadingIndicator.style.color = 'red';
      }
    }

    setupAudioGraph(){
      if(!this.audioContext){ return; }

      this.masterGain = this.audioContext.createGain();
      this.masterGain.gain.value = this.gainFromSlider(this.INITIAL_SETTINGS.master*100);

      /* Global EQ chain */
      const low = this.audioContext.createBiquadFilter(); low.type='lowshelf'; low.frequency.value = 200; low.gain.value = 0;
      const mid = this.audioContext.createBiquadFilter(); mid.type='peaking';  mid.frequency.value = 500; mid.Q.value = 0.7; mid.gain.value = 0;
      const high= this.audioContext.createBiquadFilter(); high.type='highshelf'; high.frequency.value = 2000; high.gain.value = 0;
      const dark= this.audioContext.createBiquadFilter(); dark.type='lowpass'; dark.frequency.value = 20000; dark.Q.value = 0.7;

      this.eq = { low, mid, high, dark };

      /* Soft limiter */
      this.limiter = this.audioContext.createDynamicsCompressor();
      this.limiter.threshold.value = -1.0;
      this.limiter.knee.value = 12;
      this.limiter.ratio.value = 12;
      this.limiter.attack.value = 0.003;
      this.limiter.release.value = 0.08;

      /* connect: master -> EQ -> limiter -> destination */
      this.masterGain.connect(low);
      low.connect(mid); mid.connect(high); high.connect(dark); dark.connect(this.limiter);
      this.limiter.connect(this.audioContext.destination);

      /* per channel setup */
      for(const channelName of this.orderedChannelNames){ this.setupChannelAudio(channelName); }

      /* default EQ mode */
      this.setEQMode('white');
    }

    setEQMode(mode){
      if(!this.eq) return;
      const { low, mid, high, dark } = this.eq;

      // reset
      low.gain.setValueAtTime(0, this.audioContext.currentTime);
      mid.gain.setValueAtTime(0, this.audioContext.currentTime);
      high.gain.setValueAtTime(0, this.audioContext.currentTime);
      dark.frequency.setValueAtTime(20000, this.audioContext.currentTime);

      if(mode === 'pink'){
        low.gain.value = +3; high.gain.value = -3; dark.frequency.value = 18000;
      } else if(mode === 'green'){
        mid.gain.value = +4; low.gain.value = -1; high.gain.value = -1; dark.frequency.value = 16000;
      } else if(mode === 'brown'){
        low.gain.value = +6; high.gain.value = -6; dark.frequency.value = 15000;
      } else if(mode === 'black'){
        low.gain.value = +4; high.gain.value = -10; dark.frequency.value = 6000;
      } // white = flat

      ['White','Pink','Green','Brown','Black'].forEach(n=>{
        const el = document.getElementById('eq'+n);
        if(el) el.classList.toggle('active', n.toLowerCase() === mode);
      });
      this.eqMode = mode;

      // refresh global tint on mode change
      this.updateTintOverlay();
    }

    setupChannelAudio(channelName){
      const channel = {};
      this.channels[channelName] = channel;

      channel.gain = this.audioContext.createGain();
      channel.gain.gain.value = this.gainFromSlider(this.channelData[channelName].initialVolume*100);

      channel.lucidEffectGainNode = this.audioContext.createGain();
      channel.gain.connect(channel.lucidEffectGainNode);

      channel.astralFilter = this.audioContext.createBiquadFilter();
      channel.astralFilter.type = 'bandpass';
      channel.astralFilter.frequency.value = 7000;
      channel.astralFilter.Q.value = 1.2;

      channel.astralWetGain = this.audioContext.createGain();
      const astralSliderElement = document.getElementById('astralSlider');
      channel.astralWetGain.gain.value = astralSliderElement ? parseFloat(astralSliderElement.value)/100 : this.INITIAL_SETTINGS.astral;

      channel.lucidEffectGainNode.connect(this.masterGain);
      channel.lucidEffectGainNode.connect(channel.astralFilter);
      channel.astralFilter.connect(channel.astralWetGain);
      channel.astralWetGain.connect(this.masterGain);

      this.astralFilters[channelName] = channel.astralFilter;

      const dcOneNode = this.audioContext.createConstantSource(); dcOneNode.offset.value = 1.0; dcOneNode.start();
      const lucidSliderElement = document.getElementById('lucidSlider');
      const initialLucidValue = lucidSliderElement ? parseFloat(lucidSliderElement.value)/100 : this.INITIAL_SETTINGS.lucid;

      const dryMixGain = this.audioContext.createGain(); dryMixGain.gain.value = 1.0 - initialLucidValue;
      const wetMixGain = this.audioContext.createGain(); wetMixGain.gain.value = initialLucidValue;

      dcOneNode.connect(dryMixGain); dryMixGain.connect(channel.lucidEffectGainNode.gain);
      wetMixGain.connect(channel.lucidEffectGainNode.gain);
      channel.lucidControls = { dryMixGain, wetMixGain };

      channel.panner = this.audioContext.createStereoPanner();
      channel.panner.pan.value = this.channelData[channelName].pan;

      const panLFO = this.audioContext.createOscillator();
      const panGain = this.audioContext.createGain(); panGain.gain.value = 0.05;
      panLFO.frequency.value = 0.005; panLFO.connect(panGain).connect(channel.panner.pan); panLFO.start();

      channel.panner.connect(channel.gain);

      channel.pair = null;
      channel.abDepth = 0;
      channel.abPhase = Math.random()*Math.PI*2;
      channel.abFreq  = 1 / (180 + Math.random()*120);
      channel.abTimer = null;
    }

    async loadAllSounds(){
      for(const channelName of this.orderedChannelNames){
        const data = this.channelData[channelName];
        this.channels[channelName].audioBuffers = [];
        for(const filename of data.files){
          try{
            const loaded = await this.loadAudioFile(`sounds/${filename}`);
            this.channels[channelName].audioBuffers.push(loaded);
          }catch{
            const silent = this.audioContext.createBuffer(1, Math.max(1, this.audioContext.sampleRate*0.02), this.audioContext.sampleRate);
            this.channels[channelName].audioBuffers.push({ buffer:silent, pregain:1 });
          }
        }
      }
    }

    computeRMS(buf){
      const ch = buf.getChannelData(0);
      let sum = 0, n = 0, step = 128;
      for(let i=0;i<ch.length;i+=step){ const s = ch[i]; sum += s*s; n++; }
      return Math.sqrt(sum/Math.max(1,n));
    }

    async loadAudioFile(url){
      const response = await fetch(url);
      if(!response.ok){ throw new Error(`HTTP ${response.status} for ${url}`); }
      const arrayBuffer = await response.arrayBuffer();
      const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
      const rms = this.computeRMS(audioBuffer);
      const target = 0.16;
      const pregain = Math.min(4, Math.max(0.25, target/(rms + 1e-6)));
      return { buffer:audioBuffer, pregain };
    }

    switchChannelSound(channelName, index){
      if(!this.isInitialized || !this.audioContext || this.audioContext.state !== 'running'){ return; }
      const ch = this.channels[channelName];
      const metaA = ch.audioBuffers[index];
      if(!metaA || !metaA.buffer || metaA.buffer.duration < 0.05){
        this.stopChannelPair(channelName);
        return;
      }
      const Bindex = (index + 1) % this.channelData[channelName].files.length;
      const metaB = ch.audioBuffers[Bindex];

      const now = this.audioContext.currentTime;
      const fade = 0.35;

      const srcA = this.audioContext.createBufferSource(); srcA.buffer = metaA.buffer; srcA.loop = true;
      const preA = this.audioContext.createGain(); preA.gain.value = metaA.pregain;
      const crossA = this.audioContext.createGain(); crossA.gain.value = 1;

      const srcB = this.audioContext.createBufferSource(); srcB.buffer = metaB.buffer; srcB.loop = true;
      const preB = this.audioContext.createGain(); preB.gain.value = metaB.pregain;
      const crossB = this.audioContext.createGain(); crossB.gain.value = 0;

      srcA.connect(preA).connect(crossA).connect(ch.panner);
      srcB.connect(preB).connect(crossB).connect(ch.panner);

      srcA.start(now); srcB.start(now);

      if(ch.pair){
        const { srcA:oldA, srcB:oldB, crossA:oldGA, crossB:oldGB } = ch.pair;
        try{
          oldGA.gain.cancelScheduledValues(now); oldGA.gain.setValueAtTime(oldGA.gain.value, now);
          oldGB.gain.cancelScheduledValues(now); oldGB.gain.setValueAtTime(oldGB.gain.value, now);
          oldGA.gain.linearRampToValueAtTime(0, now + fade);
          oldGB.gain.linearRampToValueAtTime(0, now + fade);
          oldA.stop(now + fade + 0.05);
          oldB.stop(now + fade + 0.05);
        }catch{}
      }

      ch.pair = { srcA, srcB, preA, preB, crossA, crossB, indexA:index, indexB:Bindex };
      this.updateABDepthForChannel(channelName);
      this.startABTimer(channelName);
    }

    stopChannelPair(channelName){
      const ch = this.channels[channelName];
      if(!ch || !ch.pair) return;
      const now = this.audioContext.currentTime;
      try{
        ch.pair.crossA.gain.linearRampToValueAtTime(0, now + 0.25);
        ch.pair.crossB.gain.linearRampToValueAtTime(0, now + 0.25);
        ch.pair.srcA.stop(now + 0.3);
        ch.pair.srcB.stop(now + 0.3);
      }catch{}
      ch.pair = null;
      if(ch.abTimer){ clearInterval(ch.abTimer); ch.abTimer = null; }
    }

    updateABDepthForChannel(channelName){
      const ch = this.channels[channelName];
      if(!ch) return;
      const L = parseFloat(document.getElementById('lucidSlider').value)/100;
      const depth = 0.5 * Math.pow(L, 2.0);
      ch.abDepth = depth;
    }

    startABTimer(channelName){
      const ch = this.channels[channelName];
      if(!ch || !ch.pair) return;
      if(ch.abTimer){ clearInterval(ch.abTimer); ch.abTimer = null; }

      const step = 0.5;
      ch.abTimer = setInterval(()=>{
        if(!this.isInitialized || !ch.pair) return;
        const now = this.audioContext.currentTime;

        ch.abPhase += 2*Math.PI*ch.abFreq*step;

        const base = ch.abDepth * 0.5;
        const amp  = ch.abDepth * 0.15;
        let x = base + amp * Math.sin(ch.abPhase);

        x = Math.max(0, Math.min(1, x));
        const gB = Math.sin(x * Math.PI/2);
        const gA = Math.cos(x * Math.PI/2);

        ch.pair.crossA.gain.setTargetAtTime(gA, now, 0.25);
        ch.pair.crossB.gain.setTargetAtTime(gB, now, 0.25);
      }, step*1000);
    }

    startLFOs(){
      if(!this.audioContext){ return; }

      const floorVal = 0.1;
      const lfoRange = 1.0 - floorVal;

      const createLFOEnvelope = (freq)=>{
        const osc = this.audioContext.createOscillator(); osc.frequency.value = freq; osc.type = 'sine';
        const modulationGain = this.audioContext.createGain(); modulationGain.gain.value = lfoRange/2;
        osc.connect(modulationGain);
        const baseOffset = this.audioContext.createConstantSource(); baseOffset.offset.value = (lfoRange/2) + floorVal;
        osc.start(); baseOffset.start();
        return { modulationGainNode:modulationGain, baseOffsetNode:baseOffset };
      };

      this.lucidLFOComponents.groupA = createLFOEnvelope(1/160);
      this.lucidLFOComponents.groupB = createLFOEnvelope(1/245);

      this.orderedChannelNames.forEach(name=>{
        const ch = this.channels[name];
        const group = (name === 'sky' || name === 'fire') ? this.lucidLFOComponents.groupA : this.lucidLFOComponents.groupB;
        if(ch && ch.lucidControls && ch.lucidControls.wetMixGain && group){
          group.modulationGainNode.connect(ch.lucidControls.wetMixGain);
          group.baseOffsetNode.connect(ch.lucidControls.wetMixGain);
        }
      });

      const astralFreqs = [1/160, 1/140, 1/180, 1/120];
      this.orderedChannelNames.forEach((name, i)=>{
        const lfo = this.audioContext.createOscillator();
        const lfoGain = this.audioContext.createGain();
        const baseFreqNode = this.audioContext.createConstantSource();

        lfo.frequency.value = astralFreqs[i % astralFreqs.length];
        lfo.type = 'sine';
        lfoGain.gain.value = 6000;
        baseFreqNode.offset.value = 7000;

        lfo.connect(lfoGain);
        if(this.astralFilters[name] && this.astralFilters[name].frequency){
          lfoGain.connect(this.astralFilters[name].frequency);
          baseFreqNode.connect(this.astralFilters[name].frequency);
        }
        lfo.start(); baseFreqNode.start();
        this.astralLFOs[name] = { lfo, lfoGain, baseFreqNode };
      });
    }

    updateKnobColor(elementId, percentage){
      const knobImage = document.getElementById(elementId);
      if(!knobImage) return;
      const value = parseFloat(percentage)/100;
      const hueMinDeg = 0, hueMaxDeg = 180;
      const targetHue = hueMinDeg + (hueMaxDeg - hueMinDeg)*value;
      const brightness = 0.8 + 0.4*value;
      knobImage.style.filter = `hue-rotate(${targetHue}deg) saturate(1.5) brightness(${brightness})`;
    }

    /* global tint: blend channel mix colour with EQ mode tint */
    updateTintOverlay(){
      const vSky   = parseFloat(document.getElementById('skySlider').value)/100;
      const vFire  = parseFloat(document.getElementById('fireSlider').value)/100;
      const vEarth = parseFloat(document.getElementById('earthSlider').value)/100;
      const vSea   = parseFloat(document.getElementById('seaSlider').value)/100;

      const col = (r,g,b)=>({r,g,b});
      const skyPink = col(255,105,180);
      const fireOrng= col(255,140,0);
      const earthGrn= col(46,204,113);
      const seaBlue = col(64,156,255);

      const wSum = vSky + vFire + vEarth + vSea + 1e-6;
      const chanCol = {
        r:(vSky*skyPink.r + vFire*fireOrng.r + vEarth*earthGrn.r + vSea*seaBlue.r) / wSum,
        g:(vSky*skyPink.g + vFire*fireOrng.g + vEarth*earthGrn.g + vSea*seaBlue.g) / wSum,
        b:(vSky*skyPink.b + vFire*fireOrng.b + vEarth*earthGrn.b + vSea*seaBlue.b) / wSum
      };

      const bias = this.eqTintMap[this.eqMode] || this.eqTintMap.white;
      const t = bias.weight; // how much EQ colour biases the tint
      const final = {
        r: chanCol.r*(1-t) + bias.r*t,
        g: chanCol.g*(1-t) + bias.g*t,
        b: chanCol.b*(1-t) + bias.b*t
      };

      // a bit stronger than before so it reads clearly; still capped
      const alpha = Math.min(0.22, 0.10 + 0.14 * ((wSum - 1e-6) / 4));
      const overlay = document.getElementById('tintOverlay');
      overlay.style.backgroundColor = `rgba(${final.r.toFixed(0)}, ${final.g.toFixed(0)}, ${final.b.toFixed(0)}, ${alpha.toFixed(3)})`;
    }

    fadeIn(gainParam, t, d=0.08){
      gainParam.cancelScheduledValues(t);
      gainParam.setValueAtTime(0, t);
      gainParam.linearRampToValueAtTime(1, t + d);
    }
    fadeOut(gainParam, t, d=0.08){
      gainParam.cancelScheduledValues(t);
      gainParam.setValueAtTime(gainParam.value, t);
      gainParam.linearRampToValueAtTime(0, t + d);
    }

    initializeEventListeners(){
      this.boundInitializeListener = async ()=>{
        if(!this.isInitialized){ await this.initialize(); }
        else if(this.audioContext && this.audioContext.state === 'suspended'){ await this.audioContext.resume(); }
      };
      document.addEventListener('click', this.boundInitializeListener, { once:true });

      const masterSlider = document.getElementById('masterSlider');
      const masterReadout = document.getElementById('masterReadout');
      masterSlider.addEventListener('input', (e)=>{
        if(!this.isInitialized || !this.masterGain) return;
        const t = this.audioContext.currentTime;
        const g = this.gainFromSlider(parseFloat(e.target.value));
        this.masterGain.gain.setTargetAtTime(g, t, 0.015);
        masterReadout.textContent = e.target.value;
        this.updateKnobColor('masterKnob', parseFloat(e.target.value));
        this.updateTintOverlay();
      });

      const astralSlider = document.getElementById('astralSlider');
      const astralReadout = document.getElementById('astralReadout');
      astralSlider.addEventListener('input', (e)=>{
        if(!this.isInitialized) return;
        const value = parseFloat(e.target.value)/100;
        this.orderedChannelNames.forEach(n=>{
          const ch = this.channels[n];
          if(ch && ch.astralWetGain){
            ch.astralWetGain.gain.setTargetAtTime(value, this.audioContext.currentTime, 0.015);
          }
        });
        astralReadout.textContent = e.target.value;
        this.updateKnobColor('astralKnob', parseFloat(e.target.value));
      });

      const lucidSlider = document.getElementById('lucidSlider');
      const lucidReadout = document.getElementById('lucidReadout');
      lucidSlider.addEventListener('input', (e)=>{
        if(!this.isInitialized) return;
        const L = parseFloat(e.target.value)/100;
        this.orderedChannelNames.forEach(n=>{
          const ch = this.channels[n];
          if(ch && ch.lucidControls){
            ch.lucidControls.dryMixGain.gain.setTargetAtTime(1 - L, this.audioContext.currentTime, 0.015);
            ch.lucidControls.wetMixGain.gain.setTargetAtTime(L, this.audioContext.currentTime, 0.015);
          }
          this.updateABDepthForChannel(n);
        });
        lucidReadout.textContent = e.target.value;
        this.updateKnobColor('lucidKnob', parseFloat(e.target.value));
      });

      this.orderedChannelNames.forEach(channelName=>{
        const slider  = document.getElementById(`${channelName}Slider`);
        const readout = document.getElementById(`${channelName}Readout`);
        const spinner = document.getElementById(`${channelName}Spinner`);

        slider.addEventListener('input', (e)=>{
          if(!this.isInitialized) return;
          const v = this.gainFromSlider(parseFloat(e.target.value));
          if(this.channels[channelName] && this.channels[channelName].gain){
            this.channels[channelName].gain.gain.setTargetAtTime(v, this.audioContext.currentTime, 0.015);
          }
          readout.textContent = e.target.value;
          this.updateKnobColor(`${channelName}Knob`, parseFloat(e.target.value));
          this.updateTintOverlay(); // ensure global tint reacts immediately
        });

        spinner.addEventListener('change', (e)=>{
          if(!this.isInitialized) return;
          const index = parseInt(e.target.value, 10);
          this.switchChannelSound(channelName, index);
        });
      });

      // EQ buttons
      const eqMap = {
        eqWhite:'white', eqPink:'pink', eqGreen:'green', eqBrown:'brown', eqBlack:'black'
      };
      Object.keys(eqMap).forEach(id=>{
        const mode = eqMap[id];
        const el = document.getElementById(id);
        el.addEventListener('click', ()=> this.setEQMode(mode));
      });

      document.getElementById('saveButton').addEventListener('click', ()=> this.saveState());
      document.getElementById('loadButton').addEventListener('click', ()=> this.loadState());
    }

    saveState(){
      if(!this.isInitialized){ return; }
      const state = {
        master: document.getElementById('masterSlider').value,
        astral: document.getElementById('astralSlider').value,
        lucid: document.getElementById('lucidSlider').value,
        eq: this.eqMode || 'white',
        channels: {}
      };
      this.orderedChannelNames.forEach(n=>{
        state.channels[n] = {
          volume: document.getElementById(`${n}Slider`).value,
          selection: document.getElementById(`${n}Spinner`).value
        };
      });
      localStorage.setItem('slumbr_state_v6', JSON.stringify(state));
    }

    loadState(){
      if(!this.isInitialized){ return; }
      let s = null;
      const saved = localStorage.getItem('slumbr_state_v6') || localStorage.getItem('slumbr_state_v5');
      if(saved){ try{ s = JSON.parse(saved);}catch{} }

      if(!s){
        s = {
          master: document.getElementById('masterSlider').value,
          astral: document.getElementById('astralSlider').value,
          lucid: document.getElementById('lucidSlider').value,
          eq: 'white',
          channels: {}
        };
        this.orderedChannelNames.forEach(n=>{
          s.channels[n] = {
            volume: document.getElementById(`${n}Slider`).value,
            selection: document.getElementById(`${n}Spinner`).value
          };
        });
      }

      document.getElementById('masterSlider').value = s.master;
      document.getElementById('masterSlider').dispatchEvent(new Event('input', { bubbles:true }));

      document.getElementById('astralSlider').value = s.astral;
      document.getElementById('astralSlider').dispatchEvent(new Event('input', { bubbles:true }));

      document.getElementById('lucidSlider').value = s.lucid;
      document.getElementById('lucidSlider').dispatchEvent(new Event('input', { bubbles:true }));

      if(s.channels){
        this.orderedChannelNames.forEach(n=>{
          const cs = s.channels[n];
          if(!cs) return;
          document.getElementById(`${n}Slider`).value = cs.volume;
          document.getElementById(`${n}Slider`).dispatchEvent(new Event('input', { bubbles:true }));

          document.getElementById(`${n}Spinner`).value = cs.selection;
          document.getElementById(`${n}Spinner`).dispatchEvent(new Event('change', { bubbles:true }));
        });
      }

      this.setEQMode(s.eq || 'white');
    }

    async requestWakeLock(){
      if('wakeLock' in navigator){
        try{
          this.wakeLock = await navigator.wakeLock.request('screen');
          this.wakeLock.addEventListener('release', ()=>{});
          document.addEventListener('visibilitychange', async ()=>{
            if(document.visibilityState === 'visible'){
              try{ this.wakeLock = await navigator.wakeLock.request('screen'); }catch{}
            }
          });
        }catch{}
      }
    }
  }

  const slumbr = new SlumbrApp();

  window.addEventListener('beforeunload', ()=>{
    if(slumbr.isInitialized){ slumbr.saveState(); }
  });

  if('serviceWorker' in navigator){
    window.addEventListener('load', ()=>{ navigator.serviceWorker.register('./sw.js').catch(()=>{}); });
  }
  </script>

  <div style="text-align:center; margin-top:20px;">
    <a href="https://mikewhyle.com/ai/" target="_blank" rel="noopener">
      <img src="ad-mikewhyle-ai-consultant.png" alt="AI Consultant" style="max-width:100%; height:auto;">
    </a>
  </div>
</body>
</html>
