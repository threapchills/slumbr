<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>SLUMBR</title>

  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#101020">
  <link rel="icon" type="image/png" href="astral_knob.png"/>

  <style>
    *{ margin:0; padding:0; box-sizing:border-box; }
    body{
      font-family:Arial, sans-serif;
      background:#0f1220 url('backgroundlatest.png') center/cover fixed;
      color:white;
      user-select:none;
      overflow-x:hidden;
      overflow-y:auto;
      min-height:100dvh;
      padding:0 12px 32px;
      position:relative;
    }

    .app-container{
      position:relative;
      width:min(580px, 94vw);
      aspect-ratio:540 / 835;
      height:auto;
      margin:clamp(12px, 4vh, 28px) auto;
      max-height:calc(100vh - 80px);
    }
    @supports not (aspect-ratio: 1){
      .app-container{ height:835px; }
    }

    .layer-switcher{
      position:absolute;
      top:12%;
      left:50%;
      transform:translateX(-50%);
      display:flex;
      gap:10px;
      z-index:25;
    }
    .layer-dot{
      width:14px; height:14px; border-radius:50%; border:1px solid rgba(255,255,255,0.5);
      background:rgba(0,0,0,0.7); cursor:pointer; transition:transform 0.1s ease, box-shadow 0.2s ease;
      position:relative;
    }
    .layer-dot::after{
      content:""; position:absolute; inset:3px; border-radius:50%; background:rgba(255,255,255,0.2);
      transition:opacity 0.2s ease, background 0.25s ease;
      opacity:0;
    }
    .layer-dot.active{ box-shadow:0 0 6px rgba(120,180,255,0.7); transform:scale(1.08); }
    .layer-dot.active::after{ opacity:1; background:rgba(255,255,255,0.7); }
    .layer-dot:hover{ transform:scale(1.08); }

    .layer-stack{ position:absolute; inset:0; border-radius:12px; overflow:hidden; }
    .slumbr-layer{ position:absolute; inset:0; display:none; }
    .slumbr-layer.is-active{ display:block; }

    .layer-surface{
      position:relative; width:100%; height:100%;
      background-image:url('background.png'); background-size:cover; background-position:center top; background-repeat:no-repeat;
      background-color:#070912;
    }

    .layer-surface::after{
      content:""; position:absolute; inset:0; pointer-events:none; border:1px solid rgba(255,255,255,0.08); border-radius:12px;
    }

    .layer-badge{
      position:absolute; top:26px; left:26px; background:rgba(0,0,0,0.45); padding:3px 8px; border-radius:999px;
      font-size:9px; letter-spacing:0.12em; text-transform:uppercase; opacity:0.7; pointer-events:none;
    }

    .tintOverlay{
      position:absolute; inset:0; pointer-events:none;
      background:rgba(0,0,0,0);
      transition:background-color 0.6s ease;
      mix-blend-mode: overlay;
      border-radius:12px;
    }

    .channel{
      position:absolute;
      display:flex;
      flex-direction:column;
      align-items:center;
      width:min(19vw, 110px);
      max-width:110px;
      height:240px;
      padding:4px;
      transform:translate(-50%, -50%);
    }
    .knob-container{ position:relative; width:75px; height:75px; cursor:grab; }
    .knob-container.dragging{ cursor:grabbing; }
    .knob-slider{ position:absolute; width:100%; height:100%; opacity:0; cursor:pointer; z-index:2; margin:0; }
    .knob-image{
      position:absolute; width:100%; height:100%; background-size:contain; background-repeat:no-repeat; background-position:center;
      pointer-events:none; filter:hue-rotate(180deg) saturate(1.5); transition:filter 0.1s ease, transform 0.08s ease-out;
      transform:rotate(-135deg);
    }
    .knob-readout{ width:75px; height:24px; text-align:center; font-size:12px; color:white; line-height:24px; margin-top:2px; }

    .channel-spinner{
      width:90px; height:36px; background:transparent; border:1.5px solid rgba(58,137,255,0.4); border-radius:8px;
      color:white; font-size:18px; text-align:center; text-align-last:center; cursor:pointer; padding:0 4px;
      -webkit-appearance:none; -moz-appearance:none; appearance:none;
    }
    .channel-spinner:focus{ outline:none; border-color:rgba(58,137,255,0.8); }
    select.channel-spinner option{ background:#1f1f3d; color:white; font-size:16px; }
    select.channel-spinner option:hover{ background:#3c3c5d; }

    .control-knob{ position:absolute; display:flex; flex-direction:column; align-items:center; transform:translate(-50%, -50%); }
    .control-knob.small .knob-container{ width:50px; height:50px; }
    .control-knob.small .knob-readout{ width:50px; font-size:10px; height:18px; line-height:18px; margin-top:2px; }
    .control-knob.large .knob-container{ width:150px; height:150px; cursor:grab; }
    .control-knob.large .knob-readout{ width:150px; font-size:14px; height:24px; line-height:24px; margin-top:2px; }

    .save-load-buttons{
      position:absolute;
      bottom:8px;
      left:50%;
      transform:translateX(-50%);
      display:flex;
      gap:16px;
      align-items:center;
      justify-content:center;
    }
    .save-load-button{
      width:80px;
      height:80px;
      background:rgba(255,255,255,0.04);
      border:1px solid rgba(255,255,255,0.18);
      box-shadow:0 4px 14px rgba(0,0,0,0.25);
      color:white;
      font-size:14px;
      letter-spacing:0.08em;
      text-transform:uppercase;
      cursor:pointer;
      padding:10px;
      border-radius:12px;
      transition:background-color 0.2s ease, transform 0.12s ease;
      touch-action:manipulation;
      display:flex;
      align-items:center;
      justify-content:center;
      background-size:40px 40px;
      background-position:center;
      background-repeat:no-repeat;
    }
    .save-load-button:hover{ background:rgba(255,255,255,0.12); transform:translateY(-2px); }
    .save-load-button:active{ transform:translateY(0); }
    .save-load-button.randomize{
      background:rgba(255,255,255,0.05) url('random.png') center/40px 40px no-repeat;
      border:1px solid rgba(255,255,255,0.22);
      box-shadow:0 4px 14px rgba(0,0,0,0.25);
    }
    .save-load-button.randomize:hover{
      background:rgba(255,255,255,0.16) url('random.png') center/40px 40px no-repeat;
    }
    .save-load-button.randomize:active{
      transform:scale(0.97);
    }
    .save-load-button.load{ background-image:url('load.png'); }
    .save-load-button.save{ background-image:url('save.png'); }

    .eq-buttons{ position:absolute; bottom:100px; left:50%; transform:translateX(-50%); display:flex; gap:6px; align-items:center; justify-content:center; }
    .eq-button{
      width:16px; height:16px; border-radius:50%;
      border:1px solid rgba(255,255,255,0.5); background:transparent; cursor:pointer;
      box-shadow:0 0 0 0 rgba(0,0,0,0) inset;
      transition: box-shadow 0.2s ease, transform 0.05s ease;
    }
    .eq-button:active{ transform: scale(0.96); }
    .eq-button.active{ box-shadow:0 0 0 2px rgba(255,255,255,0.45) inset; }

    .eq-white{ background: rgba(255,255,255,0.28); }
    .eq-pink { background: rgba(255,105,180,0.32); }
    .eq-green{ background: rgba(46,204,113,0.32); }
    .eq-brown{ background: rgba(165,94,41,0.32); }
    .eq-black{ background: rgba(20,24,30,0.55); }

    .channel.sky{ left:28%; top:56%; }
    .channel.fire{ left:72%; top:56%; }
    .channel.earth{ left:28%; top:86%; }
    .channel.sea{ left:72%; top:86%; }
    .control-knob.astral{ left:38%; top:32%; }
    .control-knob.lucid{ left:62%; top:32%; }
    .control-knob.master{ left:50%; top:69%; }

    .channel-content{ display:flex; flex-direction:column; align-items:center; justify-content:center; gap:4px; width:100%; }
    .channel.earth .channel-content > .channel-spinner,
    .channel.sea  .channel-content > .channel-spinner{ order:1; }
    .channel.earth .channel-content > .knob-container,
    .channel.sea  .channel-content > .knob-container{ order:2; }
    .channel.earth .channel-content > .knob-readout,
    .channel.sea  .channel-content > .knob-readout{ order:3; }
    .channel.sky .channel-content > .knob-container,
    .channel.fire .channel-content > .knob-container{ order:1; }
    .channel.sky .channel-content > .knob-readout,
    .channel.fire .channel-content > .knob-readout{ order:2; }
    .channel.sky .channel-content > .channel-spinner,
    .channel.fire .channel-content > .channel-spinner{ order:3; }

    .loading-indicator{
      position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      color:white; font-size:18px; text-align:center; padding:20px; background-color:rgba(0,0,0,0.5); border-radius:8px;
      cursor:pointer;
      touch-action:manipulation;
    }
    .progress{ margin-top:12px; width:260px; height:6px; background:rgba(255,255,255,0.15); border-radius:3px; overflow:hidden; }
    .progress-bar{ height:100%; width:0%; background:#2ecc71; transition:width 0.2s ease; }

    .lazy-loading-status{
      position:absolute;
      bottom:160px;
      left:50%;
      transform:translateX(-50%);
      padding:8px 14px;
      background:rgba(0,0,0,0.45);
      border:1px solid rgba(255,255,255,0.18);
      border-radius:999px;
      font-size:12px;
      letter-spacing:0.05em;
      display:none;
    }

    .channel-spinner.loading{ opacity:0.65; }
    .hint-target-highlight{ z-index:260; outline:2px solid rgba(126,188,255,0.65); box-shadow:0 0 18px rgba(70,130,255,0.45); border-radius:12px; transition:box-shadow 0.3s ease; }
    .hint-overlay__bubble{ --hint-arrow-offset:50%; }
    .hint-overlay__bubble[data-placement="top"]::after{ top:100%; bottom:auto; transform:translateX(calc(var(--hint-arrow-offset) * -1 + 50%)) rotate(45deg); }
    .hint-overlay__bubble[data-placement="bottom"]::after{ bottom:100%; top:auto; transform:translateX(calc(var(--hint-arrow-offset) * -1 + 50%)) rotate(45deg); }
    .hint-overlay__bubble::after{ left:var(--hint-arrow-offset); }
    .layer-theme-blue .layer-surface{ filter:hue-rotate(-12deg) saturate(1.08); }
    .layer-theme-green .layer-surface{ filter:hue-rotate(28deg) saturate(1.05); }
    .layer-theme-red .layer-surface{ filter:hue-rotate(-58deg) saturate(1.12); }

    @media (max-width:720px){
      body{ background-attachment:scroll; }
      .layer-switcher{ top:14%; }
      .channel.sky{ top:58%; left:26%; }
      .channel.fire{ top:58%; left:74%; }
      .channel.earth{ top:89%; left:26%; }
      .channel.sea{ top:89%; left:74%; }
      .control-knob.master{ top:72%; }
    }

    @media (max-width:560px){
      body{ padding:0 6px 24px; }
      .app-container{
        width:100%;
        max-width:420px;
        margin:clamp(8px, 4vh, 20px) auto;
        max-height:none;
      }
      .layer-switcher{ top:16%; }
      .channel{ width:min(24vw, 110px); }
      .channel.sky{ left:28%; top:60%; }
      .channel.fire{ left:72%; top:60%; }
      .channel.earth{ left:28%; top:92%; }
      .channel.sea{ left:72%; top:92%; }
      .control-knob.master{ top:74%; }
    }

    .hint-overlay{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; pointer-events:none; z-index:300; }
    .hint-overlay.is-visible{ display:flex; }
    .hint-overlay__backdrop{ position:absolute; inset:0; background:rgba(8,10,22,0.72); backdrop-filter:blur(2px); }
    .hint-overlay__bubble{ position:absolute; max-width:min(320px, 80vw); background:rgba(18,20,38,0.82); border:1px solid rgba(255,255,255,0.25); border-radius:14px; padding:16px 18px 48px; color:#f4f6ff; box-shadow:0 12px 40px rgba(0,0,0,0.35); pointer-events:auto; backdrop-filter:blur(4px); }
    .hint-overlay__bubble::after{ content:""; position:absolute; width:18px; height:18px; background:inherit; border:inherit; border-radius:4px; transform:rotate(45deg); top:100%; left:50%; margin-top:-2px; }
    .hint-overlay__title{ font-size:16px; font-weight:600; margin-bottom:6px; letter-spacing:0.03em; }
    .hint-overlay__body{ font-size:13px; line-height:1.5; opacity:0.9; }
    .hint-overlay__controls{ position:absolute; right:14px; bottom:12px; display:flex; gap:8px; }
    .hint-overlay__controls button{ background:rgba(255,255,255,0.08); color:#f5f7ff; border:1px solid rgba(255,255,255,0.15); border-radius:999px; padding:6px 14px; font-size:12px; letter-spacing:0.05em; text-transform:uppercase; cursor:pointer; }
    .hint-overlay__controls button:hover{ background:rgba(255,255,255,0.18); }
    .hint-overlay__progress{ position:absolute; top:14px; right:18px; font-size:11px; letter-spacing:0.12em; text-transform:uppercase; opacity:0.72; }
    .hint-replay-button{ position:absolute; top:14px; right:14px; width:26px; height:26px; border-radius:50%; border:0; background:rgba(255,255,255,0.82); color:#05060a; font-weight:700; font-size:15px; line-height:26px; text-align:center; cursor:pointer; box-shadow:0 4px 12px rgba(0,0,0,0.25); opacity:0.65; transition:opacity 0.2s ease, transform 0.2s ease; z-index:310; }
    .hint-replay-button:hover{ opacity:1; transform:translateY(-1px); }
    .hint-replay-button:focus-visible{ outline:2px solid rgba(70,130,255,0.8); outline-offset:3px; opacity:1; }
</style></style>
</head>
<body>
  <div class="app-container">
    <button type="button" class="hint-replay-button" data-action="show-hints" aria-label="Show SLUMBR guide">?</button>
    <div class="layer-switcher" role="tablist" aria-label="Sound layer selector">
      <button class="layer-dot active" data-index="0" aria-label="Aurora layer"></button>
      <button class="layer-dot" data-index="1" aria-label="Verdant layer"></button>
      <button class="layer-dot" data-index="2" aria-label="Crimson layer"></button>
    </div>
    <div id="layerStack" class="layer-stack"></div>
  </div>

  <template id="slumbrLayerTemplate">
    <div class="slumbr-layer">
      <div class="layer-surface">
        <div class="layer-badge" data-id="layerBadge">Layer</div>
        <div class="tintOverlay" data-id="tintOverlay" aria-hidden="true"></div>

        <div class="loading-indicator" data-id="loadingIndicator" aria-live="polite">
          <div data-id="loadingText">Start SLUMBR</div>
          <div class="progress" aria-hidden="true">
            <div class="progress-bar" data-id="progressBar" style="width:0%"></div>
          </div>
        </div>

        <div class="lazy-loading-status" data-id="lazyStatus" aria-live="polite" hidden>Loading extended library…</div>

        <div class="control-knob astral small">
          <div class="knob-container small">
            <input type="range" min="0" max="100" value="60" class="knob-slider small" data-id="astralSlider" aria-label="Astral wet amount">
            <div class="knob-image small" data-id="astralKnob" style="background-image:url('astral_knob.png');" role="img" aria-label="Astral control"></div>
          </div>
          <div class="knob-readout" data-id="astralReadout" aria-live="polite">60</div>
        </div>

        <div class="control-knob lucid small">
          <div class="knob-container small">
            <input type="range" min="0" max="100" value="60" class="knob-slider small" data-id="lucidSlider" aria-label="Lucid modulation depth">
            <div class="knob-image small" data-id="lucidKnob" style="background-image:url('lucid_knob.png');" role="img" aria-label="Lucid control"></div>
          </div>
          <div class="knob-readout" data-id="lucidReadout" aria-live="polite">60</div>
        </div>

        <div class="channel sky">
          <div class="channel-content">
            <div class="knob-container">
              <input type="range" min="0" max="100" value="50" class="knob-slider" data-id="skySlider" aria-label="Sky channel volume">
              <div class="knob-image" data-id="skyKnob" style="background-image:url('sky_knob.png');" role="img" aria-label="Sky channel knob"></div>
            </div>
            <div class="knob-readout" data-id="skyReadout" aria-live="polite">50</div>
            <select class="channel-spinner" data-id="skySpinner" aria-label="Sky sound">
              <option value="0">Tempest</option><option value="1">Breeze</option><option value="2">Balmy</option>
              <option value="3">Temple</option><option value="4">Rain</option><option value="5">Mountains</option><option value="6">Spring</option>
            </select>
          </div>
        </div>

        <div class="channel fire">
          <div class="channel-content">
            <div class="knob-container">
              <input type="range" min="0" max="100" value="50" class="knob-slider" data-id="fireSlider" aria-label="Fire channel volume">
              <div class="knob-image" data-id="fireKnob" style="background-image:url('fire_knob.png');" role="img" aria-label="Fire channel knob"></div>
            </div>
            <div class="knob-readout" data-id="fireReadout" aria-live="polite">50</div>
            <select class="channel-spinner" data-id="fireSpinner" aria-label="Fire sound">
              <option value="0">Hearth</option><option value="1">Forge</option><option value="2">Ember</option>
              <option value="3">Crackle</option><option value="4">Campfire</option><option value="5">Summer</option><option value="6">Desert</option>
            </select>
          </div>
        </div>

        <div class="control-knob master large">
          <div class="knob-container large">
            <input type="range" min="0" max="100" value="40" class="knob-slider large" data-id="masterSlider" aria-label="Master volume">
            <div class="knob-image large" data-id="masterKnob" style="background-image:url('master_knob.png');" role="img" aria-label="Master knob"></div>
          </div>
          <div class="knob-readout" data-id="masterReadout" aria-live="polite">40</div>
        </div>

        <div class="channel earth">
          <div class="channel-content">
            <select class="channel-spinner" data-id="earthSpinner" aria-label="Earth sound">
              <option value="0">Kiln</option><option value="1">Magma</option><option value="2">Crevasse</option>
              <option value="3">Core</option><option value="4">Forest</option><option value="5">Autumn</option><option value="6">Cave</option>
            </select>
            <div class="knob-container">
              <input type="range" min="0" max="100" value="50" class="knob-slider" data-id="earthSlider" aria-label="Earth channel volume">
              <div class="knob-image" data-id="earthKnob" style="background-image:url('earth_knob.png');" role="img" aria-label="Earth channel knob"></div>
            </div>
            <div class="knob-readout" data-id="earthReadout" aria-live="polite">50</div>
          </div>
        </div>

        <div class="channel sea">
          <div class="channel-content">
            <select class="channel-spinner" data-id="seaSpinner" aria-label="Sea sound">
              <option value="0">Stormy</option><option value="1">Brook</option><option value="2">Winter</option>
              <option value="3">Lake</option><option value="4">Deep</option><option value="5">Glade</option><option value="6">Creek</option>
            </select>
            <div class="knob-container">
              <input type="range" min="0" max="100" value="50" class="knob-slider" data-id="seaSlider" aria-label="Sea channel volume">
              <div class="knob-image" data-id="seaKnob" style="background-image:url('sea_knob.png');" role="img" aria-label="Sea channel knob"></div>
            </div>
            <div class="knob-readout" data-id="seaReadout" aria-live="polite">50</div>
          </div>
        </div>

        <div class="eq-buttons" aria-label="EQ presets">
          <button class="eq-button eq-white active" data-id="eqWhite" title="White EQ" aria-label="White EQ"></button>
          <button class="eq-button eq-pink"  data-id="eqPink"  title="Pink EQ"  aria-label="Pink EQ"></button>
          <button class="eq-button eq-green" data-id="eqGreen" title="Green EQ" aria-label="Green EQ"></button>
          <button class="eq-button eq-brown" data-id="eqBrown" title="Brown EQ" aria-label="Brown EQ"></button>
          <button class="eq-button eq-black" data-id="eqBlack" title="Black EQ" aria-label="Black EQ"></button>
        </div>

        <div class="save-load-buttons">
          <button class="save-load-button load" data-id="loadButton" aria-label="Load preset" type="button"></button>
          <button class="save-load-button randomize" data-id="randomizeButton" aria-label="Randomize preset" type="button"></button>
          <button class="save-load-button save" data-id="saveButton" aria-label="Save preset" type="button"></button>
        </div>
      </div>
    </div>
  </template>

  <div id="hintOverlay" class="hint-overlay" aria-hidden="true">
    <div class="hint-overlay__backdrop" data-role="backdrop"></div>
    <div class="hint-overlay__bubble" role="dialog" aria-modal="true" aria-labelledby="hintOverlayTitle" aria-describedby="hintOverlayBody">
      <div class="hint-overlay__progress" id="hintOverlayProgress"></div>
      <div class="hint-overlay__title" id="hintOverlayTitle"></div>
      <div class="hint-overlay__body" id="hintOverlayBody"></div>
      <div class="hint-overlay__controls">
        <button type="button" data-action="prev">Prev</button>
        <button type="button" data-action="next">Next</button>
        <button type="button" data-action="dismiss">Close</button>
      </div>
    </div>
  </div>

  <script>
  class SlumbrLayer {
    constructor(root, index, options={}){
      this.root = root;
      this.index = index;
      this.options = options;
      this.audioContext = null;
      this.isInitialized = false;

      this.channels = {};
      this.masterGain = null;
      this.eq = null;
      this.limiter = null;

      this.lucidLFOComponents = {};
      this.astralLFOs = {};
      this.astralFilters = {};

      this.wakeLock = null;

      this.eqMode = 'white';
      this.startEvents = ['pointerdown','touchstart','click'];
      this.suppressUserStartCallback = false;
      this.initializingPromise = null;

      this.corePreloadCount = 3;
      this.channelLoadStatus = {};
      this.pendingSpinnerSelections = {};
      this.lazyLoadingPromise = null;
      this.lazyLoadTotal = 0;
      this.lazyLoadDone = 0;
      this.eqTintMap = {
        white:{ r:255, g:255, b:255, weight:0.18 },
        pink: { r:255, g:120, b:200, weight:0.42 },
        green:{ r:46,  g:204, b:113, weight:0.42 },
        brown:{ r:165, g:94,  b:41,  weight:0.42 },
        black:{ r:24,  g:28,  b:36,  weight:0.55 }
      };

      this.INITIAL_SETTINGS = {
        master: 0.40,
        sky: 0.50,
        fire: 0.50,
        earth: 0.50,
        sea: 0.50,
        astral: 0.60,
        lucid: 0.60
      };

      /* A/B pairing maps */
      this.channelData = {
        sky: {
          files:['sky1.ogg','sky2.ogg','sky3.ogg','sky4.ogg','sky5.ogg','sky6.ogg','sky7.ogg'],
          labels:['Tempest','Breeze','Balmy','Temple','Rain','Mountains','Spring'],
          initialVolume:this.INITIAL_SETTINGS.sky, pan:+0.40,
          abMap:{ 0:3, 1:4, 2:5, 3:0, 4:1, 5:6, 6:2 }
        },
        fire:{
          files:['fire1.ogg','fire2.ogg','fire3.ogg','fire4.ogg','fire5.ogg','fire6.ogg','fire7.ogg'],
          labels:['Hearth','Forge','Ember','Crackle','Campfire','Summer','Desert'],
          initialVolume:this.INITIAL_SETTINGS.fire, pan:-0.50,
          abMap:{ 0:6, 1:2, 2:5, 3:0, 4:1, 5:3, 6:4 }
        },
        earth:{
          files:['earth1.ogg','earth2.ogg','earth3.ogg','earth4.ogg','earth5.ogg','earth6.ogg','earth7.ogg'],
          labels:['Kiln','Magma','Crevasse','Core','Forest','Autumn','Cave'],
          initialVolume:this.INITIAL_SETTINGS.earth, pan:-0.30,
          abMap:{ 0:6, 1:4, 2:5, 3:1, 4:2, 5:0, 6:3 }
        },
        sea:{
          files:['sea1.ogg','sea2.ogg','sea3.ogg','sea4.ogg','sea5.ogg','sea6.ogg','sea7.ogg'],
          labels:['Stormy','Brook','Winter','Lake','Deep','Glade','Creek'],
          initialVolume:this.INITIAL_SETTINGS.sea, pan:+0.60,
          abMap:{ 0:3, 1:4, 2:6, 3:0, 4:1, 5:2, 6:5 }
        }
      };
      this.orderedChannelNames = ['sky','fire','earth','sea'];

      this.layerTintBias = options.baseTint || null;
      this.layerTintBiasWeight = options.baseTintWeight ?? 0.2;

      this.decorateSpinnerOptions();
      this.initializeEventListeners();
      this.setupKnobGestures();
      if(this.el('layerBadge') && options.label){ this.el('layerBadge').textContent = options.label; }
      if(this.el('loadingText') && options.startText){ this.el('loadingText').textContent = options.startText; }
      this.refreshInitialKnobColours();
    }

    el(id){ return this.root.querySelector(`[data-id="${id}"]`); }
    els(selector){ return Array.from(this.root.querySelectorAll(selector)); }

    decorateSpinnerOptions(){
      this.orderedChannelNames.forEach(name=>{
        const spinner = this.el(`${name}Spinner`);
        if(!spinner) return;
        Array.from(spinner.options || []).forEach(opt=>{
          opt.dataset.index = opt.value;
        });
        spinner.classList.add('loading');
      });
    }

    setupKnobGestures(){
      const bindDrag = (slider, container)=>{
        const getRange = ()=>({ min: parseFloat(slider.min || '0'), max: parseFloat(slider.max || '100') });
        const clamp = (val)=>{
          const { min, max } = getRange();
          return Math.min(max, Math.max(min, val));
        };
        const stepValue = ()=>{
          const step = slider.step && slider.step !== 'any' ? parseFloat(slider.step) : 1;
          return Number.isFinite(step) && step > 0 ? step : 1;
        };

        slider.addEventListener('pointerdown', (event)=>{
          if(event.pointerType === 'mouse' && event.button !== 0) return;
          event.preventDefault();
          slider.focus({ preventScroll:true });
          const pointerId = event.pointerId;
          const startY = event.clientY;
          const startX = event.clientX;
          const startValue = parseFloat(slider.value);
          const { min, max } = getRange();
          const range = max - min;
          const isLarge = container.classList.contains('large');
          const sensitivity = isLarge ? 170 : 120;
          container.classList.add('dragging');
          slider.setPointerCapture(pointerId);

          const handleMove = (ev)=>{
            if(ev.pointerId !== pointerId) return;
            const deltaY = startY - ev.clientY;
            const deltaX = ev.clientX - startX;
            const delta = deltaY + deltaX*0.25;
            let next = startValue + (delta / sensitivity) * range;
            next = clamp(next);
            next = Math.round(next);
            if(next !== parseFloat(slider.value)){
              slider.value = String(next);
              slider.dispatchEvent(new Event('input', { bubbles:true }));
            }
          };

          const handleEnd = (ev)=>{
            if(ev.pointerId !== pointerId) return;
            container.classList.remove('dragging');
            slider.releasePointerCapture(pointerId);
            container.removeEventListener('pointermove', handleMove);
            container.removeEventListener('pointerup', handleEnd);
            container.removeEventListener('pointercancel', handleEnd);
          };

          container.addEventListener('pointermove', handleMove);
          container.addEventListener('pointerup', handleEnd);
          container.addEventListener('pointercancel', handleEnd);
        });

        container.addEventListener('wheel', (event)=>{
          if(event.ctrlKey) return;
          event.preventDefault();
          const direction = event.deltaY < 0 ? 1 : -1;
          const next = clamp(parseFloat(slider.value) + direction * stepValue());
          if(next !== parseFloat(slider.value)){
            slider.value = String(Math.round(next));
            slider.dispatchEvent(new Event('input', { bubbles:true }));
          }
        }, { passive:false });
      };

      this.els('.knob-container').forEach(container=>{
        const slider = container.querySelector('.knob-slider');
        if(!slider) return;
        bindDrag(slider, container);
      });
    }

    gainFromSlider(v){ return Math.pow(v/100, 2.2); }
    randBetween(min,max){ return min + Math.random()*(max-min); }
    randomInt(min, max){ return Math.floor(Math.random()*(max - min + 1)) + min; }

    removeStartListeners(){
      if(!this.startEvents || !this.boundInitializeListener) return;
      this.startEvents.forEach(evt=>{
        this.root.removeEventListener(evt, this.boundInitializeListener);
      });
    }

    addStartListeners(){
      if(!this.startEvents || !this.boundInitializeListener) return;
      this.startEvents.forEach(evt=>{
        const options = evt === 'click' ? false : { passive:true };
        this.root.addEventListener(evt, this.boundInitializeListener, options);
      });
    }

    async externalInitialize(){
      if(this.isInitialized) return;
      this.suppressUserStartCallback = true;
      this.removeStartListeners();
      try{
        await this.initialize();
      }catch(err){
        console.error(`Failed to initialize layer ${this.index}:`, err);
      }finally{
        this.suppressUserStartCallback = false;
      }
    }

    async initialize(){
      if(this.isInitialized) return;
      if(this.initializingPromise){ return this.initializingPromise; }

      const loadingIndicator = this.el('loadingIndicator');
      const runInitialization = async ()=>{
        try{
          this.audioContext = SlumbrLayer.getAudioContext();
          if(this.audioContext.state === 'suspended'){ await this.audioContext.resume(); }
          if(this.audioContext.state !== 'running'){
            if(loadingIndicator){ loadingIndicator.textContent = 'AudioContext not running. Tap again.'; }
            this.addStartListeners();
            return;
          }

          this.setupAudioGraph();
          this.startLFOs();

          await this.loadAllSounds();

          this.isInitialized = true;
          if(loadingIndicator){ loadingIndicator.style.display = 'none'; loadingIndicator.style.color = ''; }
          this.loadState();

          this.requestWakeLock();
          this.updateTintOverlay();
          this.updatePanWidthFromAstral();
        }catch(err){
          console.error('Failed to initialize SLUMBR:', err);
          if(loadingIndicator){
            loadingIndicator.textContent = `Error: ${err.message}. Try refreshing.`;
            loadingIndicator.style.color = 'red';
          }
        }finally{
          this.initializingPromise = null;
        }
      };

      this.initializingPromise = runInitialization();
      return this.initializingPromise;
    }

    setupAudioGraph(){
      if(!this.audioContext){ return; }

      this.masterGain = this.audioContext.createGain();
      this.masterGain.gain.value = this.gainFromSlider(this.INITIAL_SETTINGS.master*100);

      const low = this.audioContext.createBiquadFilter(); low.type='lowshelf'; low.frequency.value = 200; low.gain.value = 0;
      const mid = this.audioContext.createBiquadFilter(); mid.type='peaking';  mid.frequency.value = 500; mid.Q.value = 0.7; mid.gain.value = 0;
      const high= this.audioContext.createBiquadFilter(); high.type='highshelf'; high.frequency.value = 2000; high.gain.value = 0;
      const dark= this.audioContext.createBiquadFilter(); dark.type='lowpass'; dark.frequency.value = 20000; dark.Q.value = 0.7;

      this.eq = { low, mid, high, dark };

      this.limiter = this.audioContext.createDynamicsCompressor();
      this.limiter.threshold.value = -1.0;
      this.limiter.knee.value = 12;
      this.limiter.ratio.value = 12;
      this.limiter.attack.value = 0.003;
      this.limiter.release.value = 0.08;

      this.masterGain.connect(low);
      low.connect(mid); mid.connect(high); high.connect(dark); dark.connect(this.limiter);
      this.limiter.connect(this.audioContext.destination);

      for(const channelName of this.orderedChannelNames){ this.setupChannelAudio(channelName); }

      this.setEQMode('white');
    }

    setEQMode(mode){
      if(!this.eq) return;
      const { low, mid, high, dark } = this.eq;

      low.gain.setValueAtTime(0, this.audioContext.currentTime);
      mid.gain.setValueAtTime(0, this.audioContext.currentTime);
      high.gain.setValueAtTime(0, this.audioContext.currentTime);
      dark.frequency.setValueAtTime(20000, this.audioContext.currentTime);

      if(mode === 'pink'){
        low.gain.value = +3; high.gain.value = -3; dark.frequency.value = 18000;
      } else if(mode === 'green'){
        mid.gain.value = +4; low.gain.value = -1; high.gain.value = -1; dark.frequency.value = 16000;
      } else if(mode === 'brown'){
        low.gain.value = +6; high.gain.value = -6; dark.frequency.value = 15000;
      } else if(mode === 'black'){
        low.gain.value = +4; high.gain.value = -10; dark.frequency.value = 6000;
      }

      ['White','Pink','Green','Brown','Black'].forEach(n=>{
        const el = this.el('eq'+n);
        if(el) el.classList.toggle('active', n.toLowerCase() === mode);
      });
      this.eqMode = mode;

      this.updateTintOverlay();
    }

    setupChannelAudio(channelName){
      const channel = {};
      this.channels[channelName] = channel;

      channel.gain = this.audioContext.createGain();
      channel.gain.gain.value = this.gainFromSlider(this.channelData[channelName].initialVolume*100);

      channel.lucidEffectGainNode = this.audioContext.createGain();
      channel.gain.connect(channel.lucidEffectGainNode);

      channel.astralFilter = this.audioContext.createBiquadFilter();
      channel.astralFilter.type = 'bandpass';
      channel.astralFilter.frequency.value = 7000;
      channel.astralFilter.Q.value = 1.2;

      channel.astralWetGain = this.audioContext.createGain();
      const astralSliderElement = this.el('astralSlider');
      channel.astralWetGain.gain.value = astralSliderElement ? parseFloat(astralSliderElement.value)/100 : this.INITIAL_SETTINGS.astral;

      channel.sum = this.audioContext.createGain();

      channel.pannerA = this.audioContext.createStereoPanner();
      channel.pannerB = this.audioContext.createStereoPanner();
      channel.pannerA.pan.value = 0;
      channel.pannerB.pan.value = 0;

      channel.panLFOfreqA = this.randBetween(1/30, 1/12);
      channel.panLFOfreqB = this.randBetween(1/30, 1/12);

      channel.panLFOA = this.audioContext.createOscillator();
      channel.panLFOA.type = 'sine';
      channel.panLFOA.frequency.value = channel.panLFOfreqA;

      channel.panLFOB = this.audioContext.createOscillator();
      channel.panLFOB.type = 'sine';
      channel.panLFOB.frequency.value = channel.panLFOfreqB;

      channel.panDepthA = this.audioContext.createGain();
      channel.panDepthB = this.audioContext.createGain();
      channel.panDepthA.gain.value = 0;
      channel.panDepthB.gain.value = 0;

      channel.panLFOA.connect(channel.panDepthA).connect(channel.pannerA.pan);
      channel.panLFOB.connect(channel.panDepthB).connect(channel.pannerB.pan);
      channel.panLFOA.start();
      channel.panLFOB.start();

      channel.pannerA.connect(channel.sum);
      channel.pannerB.connect(channel.sum);

      channel.lucidEffectGainNode.connect(this.masterGain);
      channel.lucidEffectGainNode.connect(channel.astralFilter);
      channel.astralFilter.connect(channel.astralWetGain);
      channel.astralWetGain.connect(this.masterGain);

      channel.sum.connect(channel.gain);

      this.astralFilters[channelName] = channel.astralFilter;

      const dcOneNode = this.audioContext.createConstantSource(); dcOneNode.offset.value = 1.0; dcOneNode.start();
      const lucidSliderElement = this.el('lucidSlider');
      const initialLucidValue = lucidSliderElement ? parseFloat(lucidSliderElement.value)/100 : this.INITIAL_SETTINGS.lucid;

      const dryMixGain = this.audioContext.createGain(); dryMixGain.gain.value = 1.0 - initialLucidValue;
      const wetMixGain = this.audioContext.createGain(); wetMixGain.gain.value = initialLucidValue;

      dcOneNode.connect(dryMixGain); dryMixGain.connect(channel.lucidEffectGainNode.gain);
      wetMixGain.connect(channel.lucidEffectGainNode.gain);
      channel.lucidControls = { dryMixGain, wetMixGain };

      channel.pair = null;
      channel.abDepth = 0;
      channel.abPhase = Math.random()*Math.PI*2;
      channel.abFreq  = 1 / (180 + Math.random()*120);
      channel.abTimer = null;
    }

    updateLoadingProgress(done, total){
      const text = this.el('loadingText');
      const bar  = this.el('progressBar');
      const pct  = total > 0 ? Math.round((done/total)*100) : 0;
      if(text){
        text.textContent = done >= total ? 'Ready' : `Loading essentials ${pct}%`;
      }
      if(bar)  bar.style.width   = `${pct}%`;
    }

    async loadAllSounds(){
      if(!this.audioContext) return;
      const totalCore = this.orderedChannelNames.reduce((acc, name)=>{
        const files = this.channelData[name]?.files?.length || 0;
        return acc + Math.min(this.corePreloadCount, files);
      }, 0);
      let done = 0;
      this.updateLoadingProgress(0, totalCore);

      for(const channelName of this.orderedChannelNames){
        const data = this.channelData[channelName];
        if(!data) continue;
        const totalFiles = data.files.length;
        const preloadCount = Math.min(this.corePreloadCount, totalFiles);
        const channel = this.channels[channelName];
        channel.audioBuffers = new Array(totalFiles).fill(null);
        channel.loadedCount = 0;
        this.channelLoadStatus[channelName] = { loaded:0, total:totalFiles };

        for(let i=0; i<preloadCount; i++){
          const filename = data.files[i];
          try{
            const loaded = await this.loadAudioFile(`sounds/${filename}`);
            this.markSoundLoaded(channelName, i, loaded);
          }catch(err){
            console.warn(`Failed to load core sound ${filename}:`, err);
            this.markSoundLoaded(channelName, i, this.createSilentMeta());
          }finally{
            done++;
            this.updateLoadingProgress(done, totalCore);
            await this.waitForIdle();
          }
        }
      }

      this.updateLoadingProgress(totalCore, totalCore);

      this.lazyLoadTotal = this.orderedChannelNames.reduce((acc, name)=>{
        const totalFiles = this.channelData[name]?.files?.length || 0;
        const loaded = this.getLoadedCount(name);
        return acc + Math.max(0, totalFiles - loaded);
      }, 0);
      this.lazyLoadDone = 0;

      if(this.lazyLoadTotal > 0){
        this.toggleLazyStatus(true, this.lazyLoadDone, this.lazyLoadTotal);
        this.lazyLoadingPromise = this.loadRemainingSounds();
      }else{
        this.toggleLazyStatus(false);
      }
    }

    async loadRemainingSounds(){
      if(!this.audioContext || this.lazyLoadTotal <= 0) return;
      for(const channelName of this.orderedChannelNames){
        const data = this.channelData[channelName];
        if(!data) continue;
        const startIndex = this.getLoadedCount(channelName);
        const totalFiles = data.files.length;
        for(let i=startIndex; i<totalFiles; i++){
          const filename = data.files[i];
          try{
            const loaded = await this.loadAudioFile(`sounds/${filename}`);
            this.markSoundLoaded(channelName, i, loaded);
          }catch(err){
            console.warn(`Failed to lazy load ${filename}:`, err);
            this.markSoundLoaded(channelName, i, this.createSilentMeta());
          }finally{
            this.lazyLoadDone = Math.min(this.lazyLoadTotal, this.lazyLoadDone + 1);
            this.toggleLazyStatus(true, this.lazyLoadDone, this.lazyLoadTotal);
            await this.waitForIdle();
          }
        }
      }
      this.toggleLazyStatus(false);
    }

    createSilentMeta(){
      const frames = Math.max(1, this.audioContext.sampleRate * 0.02);
      const buffer = this.audioContext.createBuffer(1, frames, this.audioContext.sampleRate);
      return { buffer, pregain:1 };
    }

    toggleLazyStatus(show, done=0, total=0){
      const status = this.el('lazyStatus');
      if(!status) return;
      if(!show || total <= 0){
        status.hidden = true;
        status.style.display = 'none';
        return;
      }
      const pct = Math.min(100, Math.round((done/Math.max(1,total))*100));
      status.hidden = false;
      status.style.display = 'inline-flex';
      status.textContent = `Loading extended library… ${done}/${total} (${pct}%)`;
    }

    waitForIdle(){
      if(typeof window !== 'undefined' && 'requestIdleCallback' in window){
        return new Promise(resolve=> requestIdleCallback(()=> resolve(), { timeout:180 }));
      }
      return new Promise(resolve=> setTimeout(resolve, 32));
    }

    markSoundLoaded(channelName, index, meta){
      const channel = this.channels[channelName];
      if(!channel) return;
      if(!Array.isArray(channel.audioBuffers)){
        channel.audioBuffers = new Array(this.channelData[channelName]?.files?.length || 0).fill(null);
      }
      channel.audioBuffers[index] = meta;
      const current = typeof channel.loadedCount === 'number' ? channel.loadedCount : 0;
      channel.loadedCount = Math.max(current, index + 1);
      this.channelLoadStatus[channelName] = this.channelLoadStatus[channelName] || { loaded:0, total:this.channelData[channelName]?.files?.length || 0 };
      this.channelLoadStatus[channelName].loaded = channel.loadedCount;
      this.updateSpinnerAvailability(channelName);
      this.processPendingSelection(channelName);
    }

    getLoadedCount(channelName){
      const channel = this.channels[channelName];
      return channel && typeof channel.loadedCount === 'number' ? channel.loadedCount : 0;
    }

    getTotalSounds(channelName){
      return this.channelData[channelName]?.files?.length || 0;
    }

    isSoundLoaded(channelName, index){
      if(index === undefined || index === null || index < 0) return false;
      const channel = this.channels[channelName];
      if(!channel || !Array.isArray(channel.audioBuffers)) return false;
      const meta = channel.audioBuffers[index];
      return !!(meta && meta.buffer && meta.buffer.duration >= 0);
    }

    updateSpinnerAvailability(channelName){
      const spinner = this.el(`${channelName}Spinner`);
      if(!spinner) return;
      const loaded = this.getLoadedCount(channelName);
      const total = this.getTotalSounds(channelName);
      Array.from(spinner.options || []).forEach(opt=>{
        const idx = parseInt(opt.value, 10);
        opt.disabled = Number.isFinite(idx) ? idx >= loaded : false;
      });
      spinner.classList.toggle('loading', loaded < total);
    }

    processPendingSelection(channelName){
      const pending = this.pendingSpinnerSelections[channelName];
      if(typeof pending === 'undefined') return;
      if(this.isSoundLoaded(channelName, pending)){
        const spinner = this.el(`${channelName}Spinner`);
        if(spinner){
          spinner.value = String(pending);
          spinner.dispatchEvent(new Event('change', { bubbles:true }));
        }
        delete this.pendingSpinnerSelections[channelName];
      }
    }

    getFallbackSelection(channelName){
      const loaded = this.getLoadedCount(channelName);
      if(loaded > 0) return 0;
      return 0;
    }

    setChannelSpinnerValue(channelName, value){
      const spinner = this.el(`${channelName}Spinner`);
      if(!spinner || value === undefined || value === null) return;
      const numeric = parseInt(value, 10);
      if(!Number.isFinite(numeric)) return;
      if(this.isSoundLoaded(channelName, numeric)){
        spinner.value = String(numeric);
        spinner.dispatchEvent(new Event('change', { bubbles:true }));
        delete this.pendingSpinnerSelections[channelName];
      }else{
        const fallback = this.getLoadedCount(channelName) > 0 ? 0 : this.getFallbackSelection(channelName);
        if(this.getLoadedCount(channelName) > 0){
          spinner.value = String(fallback);
          spinner.dispatchEvent(new Event('change', { bubbles:true }));
        }
        this.pendingSpinnerSelections[channelName] = numeric;
      }
    }

    static computeRMS(buf){
      const ch = buf.getChannelData(0);
      let sum = 0, n = 0, step = 128;
      for(let i=0;i<ch.length;i+=step){ const s = ch[i]; sum += s*s; n++; }
      return Math.sqrt(sum/Math.max(1,n));
    }

    async loadAudioFile(url){
      const shared = await SlumbrLayer.fetchSharedAudio(url);
      return shared;
    }

    getABIndex(channelName, index){
      const data = this.channelData[channelName];
      const map = data && data.abMap ? data.abMap : null;
      if(map && typeof map[index] !== 'undefined'){ return map[index]; }
      const len = data.files.length;
      return (index + 1) % len;
    }

    switchChannelSound(channelName, index){
      if(!this.isInitialized || !this.audioContext || this.audioContext.state !== 'running'){ return; }
      const ch = this.channels[channelName];
      const metaA = ch.audioBuffers[index];
      if(!metaA || !metaA.buffer || metaA.buffer.duration < 0.05){
        this.stopChannelPair(channelName);
        return;
      }
      const Bindex = this.getABIndex(channelName, index);
      const metaB = ch.audioBuffers[Bindex];

      const now = this.audioContext.currentTime;
      const fade = 0.35;

      const srcA = this.audioContext.createBufferSource(); srcA.buffer = metaA.buffer; srcA.loop = true;
      const preA = this.audioContext.createGain(); preA.gain.value = metaA.pregain;
      const crossA = this.audioContext.createGain(); crossA.gain.value = 1;

      const srcB = this.audioContext.createBufferSource(); srcB.buffer = metaB.buffer; srcB.loop = true;
      const preB = this.audioContext.createGain(); preB.gain.value = metaB.pregain;
      const crossB = this.audioContext.createGain(); crossB.gain.value = 0;

      srcA.connect(preA).connect(crossA).connect(ch.pannerA);
      srcB.connect(preB).connect(crossB).connect(ch.pannerB);

      srcA.start(now); srcB.start(now);

      if(ch.pair){
        const { srcA:oldA, srcB:oldB, crossA:oldGA, crossB:oldGB } = ch.pair;
        try{
          oldGA.gain.cancelScheduledValues(now); oldGA.gain.setValueAtTime(oldGA.gain.value, now);
          oldGB.gain.cancelScheduledValues(now); oldGB.gain.setValueAtTime(oldGB.gain.value, now);
          oldGA.gain.linearRampToValueAtTime(0, now + fade);
          oldGB.gain.linearRampToValueAtTime(0, now + fade);
          oldA.stop(now + fade + 0.05);
          oldB.stop(now + fade + 0.05);
        }catch{}
      }

      ch.pair = { srcA, srcB, preA, preB, crossA, crossB, indexA:index, indexB:Bindex };

      this.updatePanWidthFromAstral();
      this.updateABDepthForChannel(channelName);
      this.startABTimer(channelName);
    }

    stopChannelPair(channelName){
      const ch = this.channels[channelName];
      if(!ch || !ch.pair) return;
      const now = this.audioContext.currentTime;
      try{
        ch.pair.crossA.gain.linearRampToValueAtTime(0, now + 0.25);
        ch.pair.crossB.gain.linearRampToValueAtTime(0, now + 0.25);
        ch.pair.srcA.stop(now + 0.3);
        ch.pair.srcB.stop(now + 0.3);
      }catch{}
      ch.pair = null;
      if(ch.abTimer){ clearInterval(ch.abTimer); ch.abTimer = null; }
    }

    updateABDepthForChannel(channelName){
      const ch = this.channels[channelName];
      if(!ch) return;
      const L = parseFloat(this.el('lucidSlider').value)/100;
      const depth = 0.5 * Math.pow(L, 2.0);
      ch.abDepth = depth;
    }

    startABTimer(channelName){
      const ch = this.channels[channelName];
      if(!ch || !ch.pair) return;
      if(ch.abTimer){ clearInterval(ch.abTimer); ch.abTimer = null; }

      const step = 0.5;
      ch.abTimer = setInterval(()=>{
        if(!this.isInitialized || !ch.pair) return;
        const now = this.audioContext.currentTime;

        ch.abPhase += 2*Math.PI*ch.abFreq*step;

        const base = ch.abDepth * 0.5;
        const amp  = ch.abDepth * 0.15;
        let x = base + amp * Math.sin(ch.abPhase);

        x = Math.max(0, Math.min(1, x));
        const gB = Math.sin(x * Math.PI/2);
        const gA = Math.cos(x * Math.PI/2);

        ch.pair.crossA.gain.setTargetAtTime(gA, now, 0.25);
        ch.pair.crossB.gain.setTargetAtTime(gB, now, 0.25);
      }, step*1000);
    }

    updatePanWidthFromAstral(){
      const L = parseFloat(this.el('astralSlider').value)/100;
      const widthMax = 0.75;
      const depth = widthMax * Math.pow(L, 1.6);

      this.orderedChannelNames.forEach(name=>{
        const ch = this.channels[name];
        if(!ch) return;
        ch.panDepthA.gain.setTargetAtTime(depth, this.audioContext.currentTime, 0.2);
        ch.panDepthB.gain.setTargetAtTime(depth, this.audioContext.currentTime, 0.2);
        if(depth < 0.001){
          ch.pannerA.pan.setTargetAtTime(0, this.audioContext.currentTime, 0.1);
          ch.pannerB.pan.setTargetAtTime(0, this.audioContext.currentTime, 0.1);
        }
      });
    }

    startLFOs(){
      if(!this.audioContext){ return; }

      const floorVal = 0.1;
      const lfoRange = 1.0 - floorVal;

      const createLFOEnvelope = (freq)=>{
        const osc = this.audioContext.createOscillator(); osc.frequency.value = freq; osc.type = 'sine';
        const modulationGain = this.audioContext.createGain(); modulationGain.gain.value = lfoRange/2;
        osc.connect(modulationGain);
        const baseOffset = this.audioContext.createConstantSource(); baseOffset.offset.value = (lfoRange/2) + floorVal;
        osc.start(); baseOffset.start();
        return { modulationGainNode:modulationGain, baseOffsetNode:baseOffset };
      };

      this.lucidLFOComponents.groupA = createLFOEnvelope(1/160);
      this.lucidLFOComponents.groupB = createLFOEnvelope(1/245);

      this.orderedChannelNames.forEach(name=>{
        const ch = this.channels[name];
        const group = (name === 'sky' || name === 'fire') ? this.lucidLFOComponents.groupA : this.lucidLFOComponents.groupB;
        if(ch && ch.lucidControls && ch.lucidControls.wetMixGain && group){
          group.modulationGainNode.connect(ch.lucidControls.wetMixGain);
          group.baseOffsetNode.connect(ch.lucidControls.wetMixGain);
        }
      });

      const astralFreqs = [1/160, 1/140, 1/180, 1/120];
      this.orderedChannelNames.forEach((name, i)=>{
        const lfo = this.audioContext.createOscillator();
        const lfoGain = this.audioContext.createGain();
        const baseFreqNode = this.audioContext.createConstantSource();

        lfo.frequency.value = astralFreqs[i % astralFreqs.length];
        lfo.type = 'sine';
        lfoGain.gain.value = 6000;
        baseFreqNode.offset.value = 7000;

        lfo.connect(lfoGain);
        if(this.astralFilters[name] && this.astralFilters[name].frequency){
          lfoGain.connect(this.astralFilters[name].frequency);
          baseFreqNode.connect(this.astralFilters[name].frequency);
        }
        lfo.start(); baseFreqNode.start();
        this.astralLFOs[name] = { lfo, lfoGain, baseFreqNode };
      });
    }

    updateKnobColor(elementId, percentage){
      const knobImage = this.el(elementId);
      if(!knobImage) return;
      const value = parseFloat(percentage)/100;
      const hueMinDeg = 0, hueMaxDeg = 180;
      const targetHue = hueMinDeg + (hueMaxDeg - hueMinDeg)*value;
      const brightness = 0.8 + 0.4*value;
      knobImage.style.filter = `hue-rotate(${targetHue}deg) saturate(1.5) brightness(${brightness})`;
      const rotationMin = -135;
      const rotationMax = 135;
      const rotation = rotationMin + (rotationMax - rotationMin)*value;
      knobImage.style.transform = `rotate(${rotation}deg)`;
    }

    refreshInitialKnobColours(){
      ['astral','lucid','master','sky','fire','earth','sea'].forEach(name=>{
        const slider = this.el(`${name}Slider`);
        if(slider){ this.updateKnobColor(`${name}Knob`, parseFloat(slider.value)); }
      });
      this.updateTintOverlay();
    }

    updateTintOverlay(){
      const vSky   = parseFloat(this.el('skySlider').value)/100;
      const vFire  = parseFloat(this.el('fireSlider').value)/100;
      const vEarth = parseFloat(this.el('earthSlider').value)/100;
      const vSea   = parseFloat(this.el('seaSlider').value)/100;

      const col = (r,g,b)=>({r,g,b});
      const skyPink = col(255,105,180);
      const fireOrng= col(255,140,0);
      const earthGrn= col(46,204,113);
      const seaBlue = col(64,156,255);

      const wSum = vSky + vFire + vEarth + vSea + 1e-6;
      const chanCol = {
        r:(vSky*skyPink.r + vFire*fireOrng.r + vEarth*earthGrn.r + vSea*seaBlue.r) / wSum,
        g:(vSky*skyPink.g + vFire*fireOrng.g + vEarth*earthGrn.g + vSea*seaBlue.g) / wSum,
        b:(vSky*skyPink.b + vFire*fireOrng.b + vEarth*earthGrn.b + vSea*seaBlue.b) / wSum
      };

      const bias = this.eqTintMap[this.eqMode] || this.eqTintMap.white;
      const t = bias.weight;
      let final = {
        r: chanCol.r*(1-t) + bias.r*t,
        g: chanCol.g*(1-t) + bias.g*t,
        b: chanCol.b*(1-t) + bias.b*t
      };

      if(this.layerTintBias){
        const weight = Math.min(0.45, Math.max(0, this.layerTintBiasWeight));
        final = {
          r: final.r*(1-weight) + this.layerTintBias.r*weight,
          g: final.g*(1-weight) + this.layerTintBias.g*weight,
          b: final.b*(1-weight) + this.layerTintBias.b*weight
        };
      }

      const alpha = Math.min(0.92, 0.30 + 0.50 * ((wSum - 1e-6) / 4));
      const overlay = this.el('tintOverlay');
      overlay.style.backgroundColor = `rgba(${final.r.toFixed(0)}, ${final.g.toFixed(0)}, ${final.b.toFixed(0)}, ${alpha.toFixed(3)})`;
    }

    fadeIn(gainParam, t, d=0.08){
      gainParam.cancelScheduledValues(t);
      gainParam.setValueAtTime(0, t);
      gainParam.linearRampToValueAtTime(1, t + d);
    }
    fadeOut(gainParam, t, d=0.08){
      gainParam.cancelScheduledValues(t);
      gainParam.setValueAtTime(gainParam.value, t);
      gainParam.linearRampToValueAtTime(0, t + d);
    }

    initializeEventListeners(){
      this.boundInitializeListener = async ()=>{
        this.removeStartListeners();
        if(!this.suppressUserStartCallback && typeof this.options.onUserStart === 'function'){
          try{ this.options.onUserStart(this); }
          catch(err){ console.error('SLUMBR start handler error:', err); }
        }
        if(!this.isInitialized){ await this.initialize(); }
        else if(this.audioContext && this.audioContext.state === 'suspended'){ await this.audioContext.resume(); }
      };
      this.addStartListeners();

      const masterSlider = this.el('masterSlider');
      const masterReadout = this.el('masterReadout');
      masterSlider.addEventListener('input', (e)=>{
        if(!this.isInitialized || !this.masterGain) return;
        const t = this.audioContext.currentTime;
        const g = this.gainFromSlider(parseFloat(e.target.value));
        this.masterGain.gain.setTargetAtTime(g, t, 0.015);
        masterReadout.textContent = e.target.value;
        this.updateKnobColor('masterKnob', parseFloat(e.target.value));
        this.updateTintOverlay();
      });

      const astralSlider = this.el('astralSlider');
      const astralReadout = this.el('astralReadout');
      astralSlider.addEventListener('input', (e)=>{
        if(!this.isInitialized) return;
        const value = parseFloat(e.target.value)/100;
        this.orderedChannelNames.forEach(n=>{
          const ch = this.channels[n];
          if(ch && ch.astralWetGain){
            ch.astralWetGain.gain.setTargetAtTime(value, this.audioContext.currentTime, 0.015);
          }
        });
        this.updatePanWidthFromAstral();
        astralReadout.textContent = e.target.value;
        this.updateKnobColor('astralKnob', parseFloat(e.target.value));
      });

      const lucidSlider = this.el('lucidSlider');
      const lucidReadout = this.el('lucidReadout');
      lucidSlider.addEventListener('input', (e)=>{
        if(!this.isInitialized) return;
        const L = parseFloat(e.target.value)/100;
        this.orderedChannelNames.forEach(n=>{
          const ch = this.channels[n];
          if(ch && ch.lucidControls){
            ch.lucidControls.dryMixGain.gain.setTargetAtTime(1 - L, this.audioContext.currentTime, 0.015);
            ch.lucidControls.wetMixGain.gain.setTargetAtTime(L, this.audioContext.currentTime, 0.015);
          }
          this.updateABDepthForChannel(n);
        });
        lucidReadout.textContent = e.target.value;
        this.updateKnobColor('lucidKnob', parseFloat(e.target.value));
      });

      this.orderedChannelNames.forEach(channelName=>{
        const slider  = this.el(`${channelName}Slider`);
        const readout = this.el(`${channelName}Readout`);
        const spinner = this.el(`${channelName}Spinner`);

        slider.addEventListener('input', (e)=>{
          if(!this.isInitialized) return;
          const v = this.gainFromSlider(parseFloat(e.target.value));
          if(this.channels[channelName] && this.channels[channelName].gain){
            this.channels[channelName].gain.gain.setTargetAtTime(v, this.audioContext.currentTime, 0.015);
          }
          readout.textContent = e.target.value;
          this.updateKnobColor(`${channelName}Knob`, parseFloat(e.target.value));
          this.updateTintOverlay();
        });

        spinner.addEventListener('change', (e)=>{
          if(!this.isInitialized) return;
          const index = parseInt(e.target.value, 10);
          if(!Number.isFinite(index)) return;
          if(!this.isSoundLoaded(channelName, index)){
            this.pendingSpinnerSelections[channelName] = index;
            return;
          }
          this.switchChannelSound(channelName, index);
        });
      });

      const eqMap = { eqWhite:'white', eqPink:'pink', eqGreen:'green', eqBrown:'brown', eqBlack:'black' };
      Object.keys(eqMap).forEach(id=>{
        const mode = eqMap[id];
        const el = this.el(id);
        el.addEventListener('click', ()=> this.setEQMode(mode));
      });

      const saveButton = this.el('saveButton');
      if(saveButton){
        saveButton.addEventListener('click', (event)=>{
          event.preventDefault();
          if(this.options.onRequestSaveAll){
            this.options.onRequestSaveAll(this);
          }else{
            this.saveState();
          }
        });
      }

      const loadButton = this.el('loadButton');
      if(loadButton){
        loadButton.addEventListener('click', (event)=>{
          event.preventDefault();
          if(this.options.onRequestLoadAll){
            this.options.onRequestLoadAll(this);
          }else{
            this.loadState();
          }
        });
      }

      const randomizeButton = this.el('randomizeButton');
      if(randomizeButton){
        randomizeButton.addEventListener('click', (event)=>{
          event.preventDefault();
          if(this.options.onRequestRandomizeAll){
            this.options.onRequestRandomizeAll(this);
            return;
          }
          if(!this.isInitialized) return;
          const state = this.generateRandomState();
          this.applyState(state);
        });
      }
    }

    generateRandomState(){
      const eqModes = Object.keys(this.eqTintMap);
      const pickEq = eqModes[this.randomInt(0, Math.max(0, eqModes.length - 1))] || 'white';
      const randomSliderValue = (min, max)=> String(this.randomInt(min, max));
      const state = {
        master: '40',
        astral: randomSliderValue(30, 90),
        lucid: randomSliderValue(20, 85),
        eq: pickEq,
        channels: {}
      };
      this.orderedChannelNames.forEach(name=>{
        const loadedCount = Math.max(1, this.getLoadedCount(name) || Math.min(this.corePreloadCount, this.getTotalSounds(name) || 1));
        const selectionIndex = this.randomInt(0, Math.max(0, loadedCount - 1));
        state.channels[name] = {
          volume: randomSliderValue(35, 85),
          selection: String(selectionIndex)
        };
      });
      return state;
    }

    applyState(state){
      if(!this.isInitialized || !state) return;
      const applySlider = (id, value)=>{
        const el = this.el(id);
        if(!el || value === undefined || value === null) return;
        const v = Math.max(0, Math.min(100, parseInt(value, 10)));
        el.value = String(Number.isFinite(v) ? v : 0);
        el.dispatchEvent(new Event('input', { bubbles:true }));
      };
      applySlider('masterSlider', state.master ?? '40');
      applySlider('astralSlider', state.astral ?? this.el('astralSlider').value);
      applySlider('lucidSlider', state.lucid ?? this.el('lucidSlider').value);

      if(state.channels){
        this.orderedChannelNames.forEach(name=>{
          const channelState = state.channels[name];
          if(!channelState) return;
          applySlider(`${name}Slider`, channelState.volume);
          this.setChannelSpinnerValue(name, channelState.selection);
        });
      }

      const eqMode = typeof state.eq === 'string' ? state.eq : 'white';
      this.setEQMode(this.eqTintMap[eqMode] ? eqMode : 'white');
      this.updatePanWidthFromAstral();
    }

    saveState(){
      if(!this.isInitialized){ return; }
      const state = {
        master: this.el('masterSlider').value,
        astral: this.el('astralSlider').value,
        lucid: this.el('lucidSlider').value,
        eq: this.eqMode || 'white',
        channels: {}
      };
      this.orderedChannelNames.forEach(n=>{
        state.channels[n] = {
          volume: this.el(`${n}Slider`).value,
          selection: this.el(`${n}Spinner`).value
        };
      });
      localStorage.setItem(this.storageKey(), JSON.stringify(state));
    }

    loadState(){
      if(!this.isInitialized){ return; }
      let state = null;
      const saved = this.loadStoredState();
      if(saved){
        try{
          const parsed = JSON.parse(saved);
          if(parsed && typeof parsed === 'object'){ state = parsed; }
        }catch(err){
          console.warn('Failed to parse saved SLUMBR state:', err);
        }
      }
      if(!state){ state = this.generateRandomState(); }
      this.applyState(state);
    }

    storageKey(){
      return `slumbr_state_v7_layer_${this.index}`;
    }

    loadStoredState(){
      const primary = localStorage.getItem(this.storageKey());
      if(primary) return primary;
      if(this.index === 0){
        return localStorage.getItem('slumbr_state_v6') || localStorage.getItem('slumbr_state_v5');
      }
      return null;
    }

    async requestWakeLock(){
      if('wakeLock' in navigator){
        try{
          this.wakeLock = await navigator.wakeLock.request('screen');
          this.wakeLock.addEventListener('release', ()=>{});
          document.addEventListener('visibilitychange', async ()=>{
            if(document.visibilityState === 'visible'){
              try{ this.wakeLock = await navigator.wakeLock.request('screen'); }catch{}
            }
          });
        }catch{}
      }
    }

    setVisible(isVisible){
      const active = !!isVisible;
      this.root.classList.toggle('is-active', active);
      this.root.style.display = active ? 'block' : 'none';
      if(active){ this.updateTintOverlay(); }
    }

    static getAudioContext(){
      if(!SlumbrLayer.sharedAudioContext){
        SlumbrLayer.sharedAudioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      return SlumbrLayer.sharedAudioContext;
    }

    static async fetchSharedAudio(url){
      if(!SlumbrLayer.sharedAudioCache){ SlumbrLayer.sharedAudioCache = new Map(); }
      const cached = SlumbrLayer.sharedAudioCache.get(url);
      if(cached){
        return cached instanceof Promise ? cached : cached;
      }
      const ctx = SlumbrLayer.getAudioContext();
      const promise = (async ()=>{
        const response = await fetch(url, { cache:'force-cache' });
        if(!response.ok){ throw new Error(`HTTP ${response.status} for ${url}`); }
        const arrayBuffer = await response.arrayBuffer();
        const audioBuffer = await ctx.decodeAudioData(arrayBuffer);
        const rms = SlumbrLayer.computeRMS(audioBuffer);
        const target = 0.16;
        const pregain = Math.min(4, Math.max(0.25, target/(rms + 1e-6)));
        const meta = { buffer:audioBuffer, pregain };
        SlumbrLayer.sharedAudioCache.set(url, meta);
        return meta;
      })();
      SlumbrLayer.sharedAudioCache.set(url, promise);
      return promise.catch(err=>{
        if(SlumbrLayer.sharedAudioCache.get(url) === promise){
          SlumbrLayer.sharedAudioCache.delete(url);
        }
        throw err;
      });
    }
  }

  SlumbrLayer.sharedAudioContext = null;
  SlumbrLayer.sharedAudioCache = new Map();

  class SlumbrLayersManager {
    constructor(){
      this.layerStack = document.getElementById('layerStack');
      this.template = document.getElementById('slumbrLayerTemplate');
      this.layerButtons = Array.from(document.querySelectorAll('.layer-dot'));
      this.layers = [];
      this.activeIndex = 0;

      this.layerConfigs = [
        { label:'Aurora', baseTint:{ r:120, g:180, b:255 }, baseTintWeight:0.30, theme:'layer-theme-blue', startText:'Start Aurora' },
        { label:'Verdant', baseTint:{ r:110, g:240, b:170 }, baseTintWeight:0.28, theme:'layer-theme-green', startText:'Start Verdant' },
        { label:'Crimson', baseTint:{ r:255, g:150, b:160 }, baseTintWeight:0.32, theme:'layer-theme-red', startText:'Start Crimson' }
      ];

      this.layerButtons.forEach((button, idx)=>{
        button.addEventListener('click', ()=> this.activateLayer(idx));
      });

      this.layerConfigs.forEach((_, idx)=> this.ensureLayer(idx));
      this.activateLayer(0);
    }

    ensureLayer(index){
      if(this.layers[index]) return this.layers[index];
      const config = this.layerConfigs[index] || {};
      const fragment = this.template.content.firstElementChild.cloneNode(true);
      if(config.theme){ fragment.classList.add(config.theme); }
      fragment.style.display = 'none';
      this.layerStack.appendChild(fragment);

      const layerOptions = {
        ...config,
        onUserStart: (layerInstance)=> this.handleLayerUserStart(layerInstance),
        onRequestSaveAll: ()=> this.saveAll(true),
        onRequestLoadAll: ()=> this.loadAll(),
        onRequestRandomizeAll: ()=> this.randomizeAll()
      };

      const layer = new SlumbrLayer(fragment, index, layerOptions);
      this.layers[index] = layer;
      return layer;
    }

    activateLayer(index){
      const layer = this.ensureLayer(index);
      if(!layer) return;
      this.layers.forEach((l, idx)=>{ if(l){ l.setVisible(idx === index); } });
      this.layerButtons.forEach((btn, idx)=> btn.classList.toggle('active', idx === index));
      this.activeIndex = index;
    }

    saveAll(forceInitialize = false){
      this.layers.forEach(layer=>{
        if(!layer) return;
        const performSave = ()=>{ try{ layer.saveState(); }catch(err){ console.error('Failed to save layer state', err); } };
        if(layer.isInitialized){
          performSave();
        }else if(forceInitialize){
          layer.externalInitialize().then(performSave).catch(err=> console.error('Failed to start layer for save', err));
        }
      });
    }

    loadAll(){
      this.layers.forEach(layer=>{
        if(!layer) return;
        const performLoad = ()=>{ try{ layer.loadState(); }catch(err){ console.error('Failed to load layer state', err); } };
        if(layer.isInitialized){
          performLoad();
        }else{
          layer.externalInitialize().then(performLoad).catch(err=> console.error('Failed to start layer for load', err));
        }
      });
    }

    randomizeAll(){
      this.layers.forEach(layer=>{
        if(!layer) return;
        const applyRandom = ()=>{
          try{
            const state = layer.generateRandomState();
            layer.applyState(state);
          }catch(err){
            console.error('Failed to randomize layer state', err);
          }
        };
        if(layer.isInitialized){
          applyRandom();
        }else{
          layer.externalInitialize().then(applyRandom).catch(err=> console.error('Failed to start layer for randomize', err));
        }
      });
    }

    handleLayerUserStart(originLayer){
      this.layers.forEach(layer=>{
        if(layer && layer !== originLayer && !layer.isInitialized){
          layer.externalInitialize().catch(err=> console.error('Failed to auto-start layer', err));
        }
      });
    }
  }

  class SlumbrHintsGuide {
    constructor(manager){
      this.manager = manager;
      this.overlay = document.getElementById('hintOverlay');
      if(!this.overlay){ return; }

      this.titleEl = document.getElementById('hintOverlayTitle');
      this.bodyEl = document.getElementById('hintOverlayBody');
      this.progressEl = document.getElementById('hintOverlayProgress');
      this.prevBtn = this.overlay.querySelector('[data-action="prev"]');
      this.nextBtn = this.overlay.querySelector('[data-action="next"]');
      this.dismissBtn = this.overlay.querySelector('[data-action="dismiss"]');
      this.backdrop = this.overlay.querySelector('[data-role="backdrop"]');

      this.storageKey = 'slumbr_hints_v2';
      this.currentIndex = 0;
      this.activeTarget = null;
      this.extraHighlights = [];
      this.boundReposition = ()=> this.positionBubble();
      this.replayButton = document.querySelector('[data-action="show-hints"]');
      this.isOverlayActive = false;
      this.pendingShowHandle = null;

      this.safeStorage = {
        get:()=>{
          try{ return localStorage.getItem(this.storageKey); }
          catch(err){ return null; }
        },
        set:()=>{
          try{ localStorage.setItem(this.storageKey, '1'); }
          catch(err){ /* ignore */ }
        }
      };

      this.hints = [
        {
          title:'Main Volume',
          body:'Tap Start to wake SLUMBR, then sweep this master dial to command overall volume and force.',
          target:()=> this.queryActive('.control-knob.master'),
          placement:'top'
        },
        {
          title:'Element Mixers',
          body:'Each elemental lane pairs a volume wheel with a sound picker—twist for level and open the dropdown to choose the ambience.',
          target:()=> this.queryActive('.channel.sky'),
          placement:'bottom'
        },
        {
          title:'Astral & Lucid',
          body:'Blend Astral for shimmer and width, then dial Lucid to add motion—together they sculpt depth and dreamy movement.',
          target:()=> this.queryActive('.control-knob.astral'),
          extras:()=> [this.queryActive('.control-knob.lucid')].filter(Boolean),
          placement:'bottom'
        },
        {
          title:'Triplets Mode',
          body:'Use these orbit dots to run up to three realms at once—triplets mode layers richer, more nuanced textures.',
          target:()=> document.querySelector('.layer-switcher'),
          placement:'bottom'
        },
        {
          title:'Save, Load & Random',
          body:'Save tonight\'s blend, reload favourites, or randomise the full rig whenever you crave something new.',
          target:()=> this.queryActive('.save-load-buttons'),
          placement:'top'
        }
      ];

      this.attachEvents();

      if(!this.safeStorage.get()){
        window.setTimeout(()=> this.start(), 1400);
      }
    }

    queryActive(selector){
      const layer = this.manager?.layers?.[this.manager.activeIndex];
      if(!layer || !layer.root) return null;
      return layer.root.querySelector(selector);
    }

    attachEvents(){
      if(this.prevBtn){ this.prevBtn.addEventListener('click', ()=> this.prev()); }
      if(this.nextBtn){ this.nextBtn.addEventListener('click', ()=> this.next()); }
      if(this.dismissBtn){ this.dismissBtn.addEventListener('click', ()=> this.complete()); }
      if(this.backdrop){ this.backdrop.addEventListener('click', ()=> this.next()); }
      if(this.replayButton){
        this.replayButton.addEventListener('click', ()=>{
          this.start(true);
        });
      }
    }

    start(force = false){
      if(!this.overlay) return;
      if(this.isOverlayActive){
        this.show(0, force);
        return;
      }
      if(!force && this.safeStorage.get()) return;
      window.addEventListener('resize', this.boundReposition, { passive:true });
      window.addEventListener('scroll', this.boundReposition, true);
      this.clearPendingShow();
      this.show(0, force);
    }

    show(index, force = false){
      this.clearPendingShow();
      if(index < 0 || index >= this.hints.length){ this.complete(); return; }
      const hint = this.hints[index];
      this.clearHighlight();
      const target = typeof hint.target === 'function' ? hint.target() : null;
      if(!target){
        this.pendingShowHandle = window.setTimeout(()=> this.show(index, force), 120);
        return;
      }
      this.currentIndex = index;
      this.activeTarget = target;
      target.classList.add('hint-target-highlight');
      this.extraHighlights = [];
      const extras = typeof hint.extras === 'function' ? hint.extras() : [];
      extras.forEach(el=>{
        if(el){
          el.classList.add('hint-target-highlight');
          this.extraHighlights.push(el);
        }
      });
      this.overlay.classList.add('is-visible');
      this.overlay.setAttribute('aria-hidden', 'false');
      this.isOverlayActive = true;
      if(this.titleEl) this.titleEl.textContent = hint.title;
      if(this.bodyEl) this.bodyEl.textContent = hint.body;
      this.updateControls();
      this.updateProgress();
      this.positionBubble(hint.placement);
      if(force){
        this.safeStorage.set();
      }
    }

    positionBubble(preferred){
      if(!this.activeTarget) return;
      const bubble = this.overlay.querySelector('.hint-overlay__bubble');
      if(!bubble) return;
      const rect = this.activeTarget.getBoundingClientRect();
      const margin = 18;
      const placementPref = preferred || this.hints[this.currentIndex]?.placement || 'top';
      requestAnimationFrame(()=>{
        const bubbleRect = bubble.getBoundingClientRect();
        let placement = placementPref;
        let top;
        if(placement === 'top'){
          top = rect.top - bubbleRect.height - margin;
          if(top < margin){ placement = 'bottom'; top = rect.bottom + margin; }
        }else{
          top = rect.bottom + margin;
          if(top + bubbleRect.height > window.innerHeight - margin){ placement = 'top'; top = rect.top - bubbleRect.height - margin; }
        }
        top = Math.max(margin, Math.min(window.innerHeight - bubbleRect.height - margin, top));
        let left = rect.left + rect.width/2 - bubbleRect.width/2;
        left = Math.max(margin, Math.min(window.innerWidth - bubbleRect.width - margin, left));
        bubble.style.top = `${top}px`;
        bubble.style.left = `${left}px`;
        bubble.dataset.placement = placement;
        const arrowOffset = (rect.left + rect.width/2) - left;
        const clamped = Math.max(18, Math.min(bubbleRect.width - 18, arrowOffset));
        bubble.style.setProperty('--hint-arrow-offset', `${clamped}px`);
      });
    }

    updateControls(){
      if(this.prevBtn){ this.prevBtn.disabled = this.currentIndex === 0; }
      if(this.nextBtn){ this.nextBtn.textContent = this.currentIndex === this.hints.length - 1 ? 'Finish' : 'Next'; }
    }

    updateProgress(){
      if(this.progressEl){
        this.progressEl.textContent = `${this.currentIndex + 1}/${this.hints.length}`;
      }
    }

    clearPendingShow(){
      if(this.pendingShowHandle !== null){
        window.clearTimeout(this.pendingShowHandle);
        this.pendingShowHandle = null;
      }
    }

    clearHighlight(){
      if(this.activeTarget){
        this.activeTarget.classList.remove('hint-target-highlight');
        this.activeTarget = null;
      }
      if(Array.isArray(this.extraHighlights)){
        this.extraHighlights.forEach(el=> el.classList.remove('hint-target-highlight'));
      }
      this.extraHighlights = [];
    }

    next(){
      if(this.currentIndex >= this.hints.length - 1){
        this.complete();
      }else{
        this.show(this.currentIndex + 1);
      }
    }

    prev(){
      if(this.currentIndex > 0){
        this.show(this.currentIndex - 1);
      }
    }

    complete(){
      this.safeStorage.set();
      this.hide();
    }

    hide(){
      this.clearHighlight();
      this.overlay.classList.remove('is-visible');
      this.overlay.setAttribute('aria-hidden', 'true');
      this.isOverlayActive = false;
      window.removeEventListener('resize', this.boundReposition);
      window.removeEventListener('scroll', this.boundReposition, true);
      this.clearPendingShow();
    }
  }

  const slumbrLayers = new SlumbrLayersManager();
  const slumbrHints = new SlumbrHintsGuide(slumbrLayers);

  window.addEventListener('beforeunload', ()=> slumbrLayers.saveAll(false));

  if('serviceWorker' in navigator){
    window.addEventListener('load', ()=>{ navigator.serviceWorker.register('./sw.js').catch(()=>{}); });
  }
  </script>

  <div style="text-align:center; margin-top:20px;">
    <a href="https://mikewhyle.com/ai/" target="_blank" rel="noopener">
      <img src="ad-mikewhyle-ai-consultant.png" alt="AI Consultant" style="max-width:100%; height:auto;">
    </a>
  </div>
</body>
</html>
